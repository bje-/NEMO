<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>nemo.generators API documentation</title>
<meta name="description" content="Simulated electricity generators for the NEMO framework." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nemo.generators</code></h1>
</header>
<section id="section-intro">
<p>Simulated electricity generators for the NEMO framework.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (C) 2011, 2012, 2013, 2014, 2022 Ben Elliston
# Copyright (C) 2014, 2015, 2016 The University of New South Wales
# Copyright (C) 2016, 2017 IT Power (Australia)
#
# This file is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.

&#34;&#34;&#34;Simulated electricity generators for the NEMO framework.&#34;&#34;&#34;

# pylint: disable=too-many-lines
# We use class names here that upset Pylint.
# pylint: disable=invalid-name

from math import isclose

import numpy as np
import pandas as pd
import requests
from matplotlib.patches import Patch

from nemo import polygons, storage
from nemo.utils import currency, thousands, ureg


class Generator():
    &#34;&#34;&#34;Base generator class.&#34;&#34;&#34;

    # Is the generator a rotating machine?
    synchronous_p = True
    &#34;&#34;&#34;Is this a synchronous generator?&#34;&#34;&#34;

    storage_p = False
    &#34;&#34;&#34;A generator is not capable of storage by default.&#34;&#34;&#34;

    def __init__(self, polygon, capacity, label=None):
        &#34;&#34;&#34;
        Construct a base Generator.

        Arguments: installed polygon, installed capacity, descriptive label.
        &#34;&#34;&#34;
        assert capacity &gt;= 0
        self.setters = [(self.set_capacity, 0, 40)]
        self.label = self.__class__.__name__ if label is None else label
        self.capacity = capacity
        self.polygon = polygon

        # Sanity check polygon argument.
        assert not isinstance(polygon, polygons.regions.Region)
        assert 0 &lt; polygon &lt;= polygons.NUMPOLYGONS, polygon

        # Time series of dispatched power and spills
        self.series_power = {}
        self.series_spilled = {}

    def series(self):
        &#34;&#34;&#34;Return generation and spills series.&#34;&#34;&#34;
        return {&#39;power&#39;: pd.Series(self.series_power, dtype=float),
                &#39;spilled&#39;: pd.Series(self.series_spilled, dtype=float)}

    def step(self, hour, demand):
        &#34;&#34;&#34;Step the generator by one hour.&#34;&#34;&#34;
        raise NotImplementedError

    def region(self):
        &#34;&#34;&#34;Return the region the generator is in.&#34;&#34;&#34;
        return polygons.region(self.polygon)

    def capcost(self, costs):
        &#34;&#34;&#34;Return the capital cost.&#34;&#34;&#34;
        return costs.capcost_per_kw[type(self)] * self.capacity * 1000

    def opcost(self, costs):
        &#34;&#34;&#34;Return the annual operating and maintenance cost.&#34;&#34;&#34;
        return self.fixed_om_costs(costs) + \
            sum(self.series_power.values()) * self.opcost_per_mwh(costs)

    def fixed_om_costs(self, costs):
        &#34;&#34;&#34;Return the fixed O&amp;M costs.&#34;&#34;&#34;
        return costs.fixed_om_costs[type(self)] * self.capacity * 1000

    def opcost_per_mwh(self, costs):
        &#34;&#34;&#34;Return the variable O&amp;M costs.&#34;&#34;&#34;
        return costs.opcost_per_mwh[type(self)]

    def reset(self):
        &#34;&#34;&#34;Reset the generator.&#34;&#34;&#34;
        self.series_power.clear()
        self.series_spilled.clear()

    def capfactor(self):
        &#34;&#34;&#34;Capacity factor of this generator (in %).&#34;&#34;&#34;
        supplied = sum(self.series_power.values())
        hours = len(self.series_power)
        try:
            capfactor = supplied / (self.capacity * hours) * 100
            return capfactor
        except ZeroDivisionError:
            return float(&#39;nan&#39;)

    def lcoe(self, costs, years):
        &#34;&#34;&#34;Calculate the LCOE in $/MWh.&#34;&#34;&#34;
        total_cost = self.capcost(costs) / costs.annuityf * years \
            + self.opcost(costs)
        supplied = sum(self.series_power.values())
        if supplied &gt; 0:
            cost_per_mwh = total_cost / supplied
            return cost_per_mwh
        return np.inf

    def summary(self, context):
        &#34;&#34;&#34;Return a summary of the generator activity.&#34;&#34;&#34;
        costs = context.costs
        supplied = sum(self.series_power.values()) * ureg.MWh
        string = f&#39;supplied {supplied.to_compact()}&#39;
        if self.capacity &gt; 0:
            if self.capfactor() &gt; 0:
                string += f&#39;, CF {self.capfactor():.1f}%&#39;
        if sum(self.series_spilled.values()) &gt; 0:
            spilled = sum(self.series_spilled.values()) * ureg.MWh
            string += f&#39;, surplus {spilled.to_compact()}&#39;
        if self.capcost(costs) &gt; 0:
            string += f&#39;, capcost {currency(self.capcost(costs))}&#39;
        if self.opcost(costs) &gt; 0:
            string += f&#39;, opcost {currency(self.opcost(costs))}&#39;
        lcoe = self.lcoe(costs, context.years())
        if np.isfinite(lcoe) and lcoe &gt; 0:
            string += f&#39;, LCOE {currency(int(lcoe))}&#39;
        return string

    def set_capacity(self, cap):
        &#34;&#34;&#34;Change the capacity of the generator to cap GW.&#34;&#34;&#34;
        self.capacity = cap * 1000

    def __str__(self):
        &#34;&#34;&#34;Return a short string representation of the generator.&#34;&#34;&#34;
        return f&#39;{self.label} ({self.region()}:{self.polygon}), &#39; + \
            str(self.capacity * ureg.MW)

    def __repr__(self):
        &#34;&#34;&#34;Return a representation of the generator.&#34;&#34;&#34;
        return self.__str__()


# This class is not to be confused with storage.py.
# This class will go away soon.

class Storage():
    &#34;&#34;&#34;A class to give a generator storage capability.&#34;&#34;&#34;

    storage_p = True
    &#34;&#34;&#34;This generator is capable of storage.&#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Storage constructor.&#34;&#34;&#34;
        # Time series of charges
        self.series_charge = {}
        self.series_soc = {}

    def soc(self):
        &#34;&#34;&#34;Return the storage SOC (state of charge).&#34;&#34;&#34;
        raise NotImplementedError

    def record(self, hour, energy):
        &#34;&#34;&#34;Record storage.&#34;&#34;&#34;
        if hour not in self.series_charge:
            self.series_charge[hour] = 0
        self.series_charge[hour] += energy
        self.series_soc[hour] = self.soc()

    def charge_capacity(self, gen, hour):
        &#34;&#34;&#34;Return available storage capacity.

        Since a storage-capable generator can be called on multiple
        times to store energy in a single timestep, we keep track of
        how much remaining capacity is available for charging in the
        given timestep.
        &#34;&#34;&#34;
        try:
            result = gen.capacity - self.series_charge[hour]
            if result &lt; 0 or isclose(result, 0, abs_tol=1e-6):
                result = 0
            assert result &gt;= 0
            return result
        except KeyError:
            return gen.capacity

    def series(self):
        &#34;&#34;&#34;Return generation and spills series.&#34;&#34;&#34;
        return {&#39;charge&#39;: pd.Series(self.series_charge, dtype=float),
                &#39;soc&#39;: pd.Series(self.series_soc, dtype=float)}

    def store(self, hour, power):
        &#34;&#34;&#34;Abstract method to ensure that derived classes define this.&#34;&#34;&#34;
        raise NotImplementedError

    def reset(self):
        &#34;&#34;&#34;Reset a generator with storage.&#34;&#34;&#34;
        self.series_charge.clear()
        self.series_soc.clear()


class TraceGenerator(Generator):
    &#34;&#34;&#34;A generator that gets its hourly dispatch from a CSV trace file.&#34;&#34;&#34;

    csvfilename = None
    csvdata = None

    def __init__(self, polygon, capacity, label=None, build_limit=None):
        &#34;&#34;&#34;Construct a generator with a specified trace file.&#34;&#34;&#34;
        Generator.__init__(self, polygon, capacity, label)
        if build_limit is not None:
            # Override default capacity limit with build_limit
            _, _, limit = self.setters[0]
            self.setters = [(self.set_capacity, 0, min(build_limit, limit))]

    def step(self, hour, demand):
        &#34;&#34;&#34;Step method for any generator using traces.&#34;&#34;&#34;
        # self.generation must be defined by derived classes
        # pylint: disable=no-member
        generation = self.generation[hour] * self.capacity
        # optimised version of min() because TraceGenerator is a
        # heavily used class
        power = generation if generation &lt; demand else demand
        spilled = generation - power
        self.series_power[hour] = power
        self.series_spilled[hour] = spilled
        return power, spilled


class CSVTraceGenerator(TraceGenerator):
    &#34;&#34;&#34;A generator that gets its hourly dispatch from a CSV trace file.&#34;&#34;&#34;

    csvfilename = None
    csvdata = None

    def __init__(self, polygon, capacity, filename, column, label=None,
                 build_limit=None):
        &#34;&#34;&#34;Construct a generator with a specified trace file.&#34;&#34;&#34;
        TraceGenerator.__init__(self, polygon, capacity, label, build_limit)
        cls = self.__class__
        if cls.csvfilename != filename:
            # Optimisation:
            # Only if the filename changes do we invoke genfromtxt.
            if not filename.startswith(&#39;http&#39;):
                # Local file path
                traceinput = filename
            else:
                try:
                    resp = requests.request(&#39;GET&#39;, filename, timeout=5)
                except requests.exceptions.Timeout as exc:
                    raise TimeoutError(f&#39;timeout fetching {filename}&#39;) from exc
                if not resp.ok:
                    msg = f&#39;HTTP {resp.status_code}: {filename}&#39;
                    raise ConnectionError(msg)
                traceinput = resp.text.splitlines()
            cls.csvdata = np.genfromtxt(traceinput, encoding=&#39;UTF-8&#39;,
                                        delimiter=&#39;,&#39;)
            cls.csvdata = np.maximum(0, cls.csvdata)
            # check all elements are not NaNs
            assert np.all(~np.isnan(cls.csvdata)), \
                f&#39;Trace file {filename} contains NaNs; inspect file&#39;
            cls.csvfilename = filename
        self.generation = cls.csvdata[::, column]


class Wind(CSVTraceGenerator):
    &#34;&#34;&#34;Wind power.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;#417505&#39;)
    &#34;&#34;&#34;Patch for plotting&#34;&#34;&#34;
    synchronous_p = False
    &#34;&#34;&#34;Is this a synchronous generator?&#34;&#34;&#34;


class WindOffshore(Wind):
    &#34;&#34;&#34;Offshore wind power.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;darkgreen&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;


class PV(CSVTraceGenerator):
    &#34;&#34;&#34;Solar photovoltaic (PV) model.&#34;&#34;&#34;

    synchronous_p = False
    &#34;&#34;&#34;Is this a synchronous generator?&#34;&#34;&#34;


class PV1Axis(PV):
    &#34;&#34;&#34;Single-axis tracking PV.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;#fed500&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;


class Behind_Meter_PV(PV):
    &#34;&#34;&#34;Behind the meter PV.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;#ffe03d&#39;)


class CST(CSVTraceGenerator):
    &#34;&#34;&#34;Concentrating solar thermal (CST) model.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;orange&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, polygon, capacity, solarmult, shours, filename,
                 column, label=None, build_limit=None):
        &#34;&#34;&#34;
        Construct a CST generator.

        Arguments include capacity (in MW), sm (solar multiple) and
        shours (hours of storage).
        &#34;&#34;&#34;
        CSVTraceGenerator.__init__(self, polygon, capacity, filename, column,
                                   label)
        self.maxstorage = None
        self.stored = None
        self.set_storage(shours)
        self.set_multiple(solarmult)

    def set_capacity(self, cap):
        &#34;&#34;&#34;Change the capacity of the generator to cap GW.&#34;&#34;&#34;
        Generator.set_capacity(self, cap)
        self.maxstorage = self.capacity * self.shours

    def set_multiple(self, solarmult):
        &#34;&#34;&#34;Change the solar multiple of a CST plant.&#34;&#34;&#34;
        self.solarmult = solarmult

    def set_storage(self, shours):
        &#34;&#34;&#34;Change the storage capacity of a CST plant.&#34;&#34;&#34;
        self.shours = shours
        self.maxstorage = self.capacity * shours
        self.stored = 0.5 * self.maxstorage

    def step(self, hour, demand):
        &#34;&#34;&#34;Step method for CST generators.&#34;&#34;&#34;
        generation = self.generation[hour] * self.capacity * self.solarmult
        remainder = min(self.capacity, demand)
        if generation &gt; remainder:
            to_storage = generation - remainder
            generation -= to_storage
            self.stored += to_storage
            self.stored = min(self.stored, self.maxstorage)
        else:
            from_storage = min(remainder - generation, self.stored)
            generation += from_storage
            self.stored -= from_storage
            assert self.stored &gt;= 0
        assert self.stored &lt;= self.maxstorage
        assert self.stored &gt;= 0
        self.series_power[hour] = generation
        self.series_spilled[hour] = 0

        # This can happen due to rounding errors.
        generation = min(generation, demand)
        return generation, 0

    def reset(self):
        &#34;&#34;&#34;Reset the generator.&#34;&#34;&#34;
        Generator.reset(self)
        self.stored = 0.5 * self.maxstorage

    def summary(self, context):
        &#34;&#34;&#34;Return a summary of the generator activity.&#34;&#34;&#34;
        return Generator.summary(self, context) + \
            f&#39;, solar mult {self.solarmult:.2f}&#39; + \
            f&#39;, {self.shours}h storage&#39;


class ParabolicTrough(CST):
    &#34;&#34;&#34;Parabolic trough CST generator.

    This stub class allows differentiated CST costs in costs.py.
    &#34;&#34;&#34;


class CentralReceiver(CST):
    &#34;&#34;&#34;Central receiver CST generator.

    This stub class allows differentiated CST costs in costs.py.
    &#34;&#34;&#34;


class Fuelled(Generator):
    &#34;&#34;&#34;The class of generators that consume fuel.&#34;&#34;&#34;

    def __init__(self, polygon, capacity, label):
        &#34;&#34;&#34;Construct a fuelled generator.&#34;&#34;&#34;
        Generator.__init__(self, polygon, capacity, label)
        self.runhours = 0

    def reset(self):
        &#34;&#34;&#34;Reset the generator.&#34;&#34;&#34;
        Generator.reset(self)
        self.runhours = 0

    def step(self, hour, demand):
        &#34;&#34;&#34;Step method for fuelled generators.&#34;&#34;&#34;
        power = min(self.capacity, demand)
        if power &gt; 0:
            self.runhours += 1
        self.series_power[hour] = power
        self.series_spilled[hour] = 0
        return power, 0

    def summary(self, context):
        &#34;&#34;&#34;Return a summary of the generator activity.&#34;&#34;&#34;
        return Generator.summary(self, context) + \
            f&#39;, ran {thousands(self.runhours)} hours&#39;


class Hydro(Fuelled):
    &#34;&#34;&#34;Hydro power stations.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;#4582b4&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, polygon, capacity, label=None):
        &#34;&#34;&#34;Construct a hydroelectric generator.&#34;&#34;&#34;
        Fuelled.__init__(self, polygon, capacity, label)
        # capacity is in MW, but build limit is in GW
        self.setters = [(self.set_capacity, 0, capacity / 1000.)]


class PumpedHydroPump(Storage, Generator):
    &#34;&#34;&#34;Pumped hydro (pump side) model.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;darkblue&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, polygon, capacity, reservoirs, rte=0.8, label=None):
        &#34;&#34;&#34;Construct a pumped hydro storage generator.&#34;&#34;&#34;
        if not isinstance(reservoirs, storage.PumpedHydroStorage):
            raise TypeError
        Storage.__init__(self)
        Generator.__init__(self, polygon, capacity, label)
        self.reservoirs = reservoirs
        self.rte = rte

    def step(self, hour, demand):
        &#34;&#34;&#34;Return 0 as this is not a generator.&#34;&#34;&#34;
        return 0, 0

    def series(self):
        &#34;&#34;&#34;Return the combined series.&#34;&#34;&#34;
        dict1 = Hydro.series(self)
        dict2 = Storage.series(self)
        dict1.update(dict2)
        return dict1

    def soc(self):
        &#34;&#34;&#34;Return the pumped hydro SOC (state of charge).&#34;&#34;&#34;
        return self.reservoirs.soc()

    def store(self, hour, power):
        &#34;&#34;&#34;Pump water uphill for one hour.&#34;&#34;&#34;
        if self.reservoirs.last_gen == hour:
            # Can&#39;t pump and generate in the same hour.
            return 0
        power = min(self.charge_capacity(self, hour), power,
                    self.capacity)

        stored = self.reservoirs.charge(power * self.rte)
        if stored &lt; power * self.rte:
            power = (self.reservoirs.maxstorage - self.reservoirs.storage) \
                / self.rte

        if power &gt; 0:
            self.record(hour, power)
            self.reservoirs.last_pump = hour
        return power

    def reset(self):
        &#34;&#34;&#34;Reset the generator.&#34;&#34;&#34;
        Generator.reset(self)
        Storage.reset(self)
        self.reservoirs.reset()

    def summary(self, context):
        &#34;&#34;&#34;Return a summary of the generator activity.&#34;&#34;&#34;
        stg = (self.reservoirs.maxstorage * ureg.MWh).to_compact()
        return Generator.summary(self, context) + \
            f&#39;, charged {thousands(len(self.series_charge))} hours&#39; + \
            f&#39;, {stg} storage&#39;


class PumpedHydroTurbine(Hydro):
    &#34;&#34;&#34;Pumped storage hydro (generator side) model.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;powderblue&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, polygon, capacity, reservoirs, label=None):
        &#34;&#34;&#34;Construct a pumped hydro storage generator.&#34;&#34;&#34;
        if not isinstance(reservoirs, storage.PumpedHydroStorage):
            raise TypeError
        Hydro.__init__(self, polygon, capacity, label)
        self.reservoirs = reservoirs

    def step(self, hour, demand):
        &#34;&#34;&#34;Step method for pumped hydro storage.&#34;&#34;&#34;
        power = min(self.reservoirs.storage, self.capacity, demand)
        if self.reservoirs.last_pump == hour:
            # Can&#39;t pump and generate in the same hour.
            self.series_power[hour] = 0
            self.series_spilled[hour] = 0
            return 0, 0

        self.reservoirs.discharge(power)
        self.series_power[hour] = power
        self.series_spilled[hour] = 0
        if power &gt; 0:
            self.runhours += 1
            self.reservoirs.last_gen = hour
        return power, 0


class Biofuel(Fuelled):
    &#34;&#34;&#34;Model of open cycle gas turbines burning biofuel.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;wheat&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, polygon, capacity, label=None):
        &#34;&#34;&#34;Construct a biofuel generator.&#34;&#34;&#34;
        Fuelled.__init__(self, polygon, capacity, label)

    def capcost(self, costs):
        &#34;&#34;&#34;Return the capital cost (of an OCGT).&#34;&#34;&#34;
        return costs.capcost_per_kw[OCGT] * self.capacity * 1000

    def fixed_om_costs(self, costs):
        &#34;&#34;&#34;Return the fixed O&amp;M costs (of an OCGT).&#34;&#34;&#34;
        return costs.fixed_om_costs[OCGT] * self.capacity * 1000

    def opcost_per_mwh(self, costs):
        &#34;&#34;&#34;Return the variable O&amp;M costs.&#34;&#34;&#34;
        vom = costs.opcost_per_mwh[OCGT]
        fuel_cost = costs.bioenergy_price_per_gj * (3.6 / .31)  # 31% heat rate
        return vom + fuel_cost


class Biomass(Fuelled):
    &#34;&#34;&#34;Model of steam turbine burning solid biomass.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;#1d7a7a&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, polygon, capacity, label=None, heatrate=0.3):
        &#34;&#34;&#34;Construct a biomass generator.&#34;&#34;&#34;
        Fuelled.__init__(self, polygon, capacity, label)
        self.heatrate = heatrate

    def opcost_per_mwh(self, costs):
        &#34;&#34;&#34;Return the variable O&amp;M costs.&#34;&#34;&#34;
        vom = costs.opcost_per_mwh[type(self)]
        fuel_cost = costs.bioenergy_price_per_gj * (3.6 / self.heatrate)
        return vom + fuel_cost


class Fossil(Fuelled):
    &#34;&#34;&#34;Base class for GHG emitting power stations.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;grey&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, polygon, capacity, intensity, label=None):
        &#34;&#34;&#34;
        Construct a fossil fuelled generator.

        Greenhouse gas emissions intensity is given in tonnes per MWh.
        &#34;&#34;&#34;
        Fuelled.__init__(self, polygon, capacity, label)
        self.intensity = intensity

    def summary(self, context):
        &#34;&#34;&#34;Return a summary of the generator activity.&#34;&#34;&#34;
        generation = sum(self.series_power.values()) * ureg.MWh
        emissions = generation * self.intensity * (ureg.t / ureg.MWh)
        return Fuelled.summary(self, context) + \
            f&#39;, {emissions.to(&#34;Mt&#34;)} CO2&#39;


class Black_Coal(Fossil):
    &#34;&#34;&#34;Black coal power stations with no CCS.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;#121212&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, polygon, capacity, intensity=0.773, label=None):
        &#34;&#34;&#34;Construct a black coal generator.&#34;&#34;&#34;
        Fossil.__init__(self, polygon, capacity, intensity, label)

    def opcost_per_mwh(self, costs):
        &#34;&#34;&#34;Return the variable O&amp;M costs.&#34;&#34;&#34;
        vom = costs.opcost_per_mwh[type(self)]
        fuel_cost = costs.coal_price_per_gj * 8.57
        total_opcost = vom + fuel_cost + self.intensity * costs.carbon
        return total_opcost


class OCGT(Fossil):
    &#34;&#34;&#34;Open cycle gas turbine (OCGT) model.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;#ffcd96&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, polygon, capacity, intensity=0.7, label=None):
        &#34;&#34;&#34;Construct an OCGT generator.&#34;&#34;&#34;
        Fossil.__init__(self, polygon, capacity, intensity, label)

    def opcost_per_mwh(self, costs):
        &#34;&#34;&#34;Return the variable O&amp;M costs.&#34;&#34;&#34;
        vom = costs.opcost_per_mwh[type(self)]
        fuel_cost = costs.gas_price_per_gj * 11.61
        total_opcost = vom + fuel_cost + self.intensity * costs.carbon
        return total_opcost


class CCGT(Fossil):
    &#34;&#34;&#34;Combined cycle gas turbine (CCGT) model.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;#fdb462&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, polygon, capacity, intensity=0.4, label=None):
        &#34;&#34;&#34;Construct a CCGT generator.&#34;&#34;&#34;
        Fossil.__init__(self, polygon, capacity, intensity, label)

    def opcost_per_mwh(self, costs):
        &#34;&#34;&#34;Return the variable O&amp;M costs.&#34;&#34;&#34;
        vom = costs.opcost_per_mwh[type(self)]
        fuel_cost = costs.gas_price_per_gj * 6.92
        total_opcost = vom + fuel_cost + self.intensity * costs.carbon
        return total_opcost


class CCS(Fossil):
    &#34;&#34;&#34;Base class of carbon capture and storage (CCS).&#34;&#34;&#34;

    def __init__(self, polygon, capacity, intensity, capture, label=None):
        &#34;&#34;&#34;Construct a CCS generator.

        Emissions capture rate is given in the range 0 to 1.
        &#34;&#34;&#34;
        Fossil.__init__(self, polygon, capacity, intensity, label)
        assert 0 &lt;= capture &lt;= 1
        self.capture = capture

    def summary(self, context):
        &#34;&#34;&#34;Return a summary of the generator activity.&#34;&#34;&#34;
        generation = sum(self.series_power.values()) * ureg.MWh
        emissions = generation * self.intensity * (ureg.t / ureg.MWh)
        captured = emissions * self.capture
        return Fossil.summary(self, context) + \
            f&#39;, {captured.to(&#34;Mt&#34;)} captured&#39;


class Coal_CCS(CCS):
    &#34;&#34;&#34;Coal with CCS.&#34;&#34;&#34;

    def __init__(self, polygon, capacity, intensity=0.8, capture=0.85,
                 label=None):
        &#34;&#34;&#34;Construct a coal CCS generator.

        Emissions capture rate is given in the range 0 to 1.
        &#34;&#34;&#34;
        CCS.__init__(self, polygon, capacity, intensity, capture, label)

    def opcost_per_mwh(self, costs):
        &#34;&#34;&#34;Return the variable O&amp;M costs.&#34;&#34;&#34;
        vom = costs.opcost_per_mwh[type(self)]
        # thermal efficiency 31.4% (AETA 2012)
        fuel_cost = costs.coal_price_per_gj * (3.6 / 0.314)
        # t CO2/MWh
        emissions_rate = 0.103
        total_opcost = vom + fuel_cost + \
            (emissions_rate * costs.carbon) + \
            (self.intensity * self.capture * costs.ccs_storage_per_t)
        return total_opcost


class CCGT_CCS(CCS):
    &#34;&#34;&#34;CCGT with CCS.&#34;&#34;&#34;

    def __init__(self, polygon, capacity, intensity=0.4, capture=0.85,
                 label=None):
        &#34;&#34;&#34;Construct a CCGT (with CCS) generator.

        Emissions capture rate is given in the range 0 to 1.
        &#34;&#34;&#34;
        CCS.__init__(self, polygon, capacity, intensity, capture, label)

    def opcost_per_mwh(self, costs):
        &#34;&#34;&#34;Return the variable O&amp;M costs.&#34;&#34;&#34;
        vom = costs.opcost_per_mwh[type(self)]
        # thermal efficiency 43.1% (AETA 2012)
        fuel_cost = costs.gas_price_per_gj * (3.6 / 0.431)
        total_opcost = vom + fuel_cost + \
            (self.intensity * (1 - self.capture) * costs.carbon) + \
            (self.intensity * self.capture * costs.ccs_storage_per_t)
        return total_opcost


class Diesel(Fossil):
    &#34;&#34;&#34;Diesel genset model.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;#f35020&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, polygon, capacity, intensity=1.0, kwh_per_litre=3.3,
                 label=None):
        &#34;&#34;&#34;Construct a diesel generator.&#34;&#34;&#34;
        Fossil.__init__(self, polygon, capacity, intensity, label)
        self.kwh_per_litre = kwh_per_litre

    def opcost_per_mwh(self, costs):
        &#34;&#34;&#34;Return the variable O&amp;M costs.&#34;&#34;&#34;
        vom = costs.opcost_per_mwh[type(self)]
        litres_per_mwh = (1 / self.kwh_per_litre) * 1000
        fuel_cost = costs.diesel_price_per_litre * litres_per_mwh
        total_opcost = vom + fuel_cost + self.intensity * costs.carbon
        return total_opcost


class BatteryLoad(Storage, Generator):
    &#34;&#34;&#34;Battery storage (load side).&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;#b2daef&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;
    synchronous_p = False
    &#34;&#34;&#34;Is this a synchronous generator?&#34;&#34;&#34;

    def __init__(self, polygon, capacity, battery, label=None,
                 discharge_hours=None, rte=0.95):
        &#34;&#34;&#34;
        Construct a battery load (battery charging).

        battery must be an instance of storage.BatteryStorage.
        discharge_hours is a list of hours when discharging can occur
          (or, rather, when charging cannot occur).
        &#34;&#34;&#34;
        Storage.__init__(self)
        Generator.__init__(self, polygon, capacity, label)
        if not isinstance(battery, storage.BatteryStorage):
            raise TypeError
        self.battery = battery
        self.rte = rte
        shours = battery.maxstorage / capacity
        assert shours in [1, 2, 4, 8]
        self.discharge_hours = discharge_hours \
            if discharge_hours is not None else range(18, 24)

    def step(self, hour, demand):
        &#34;&#34;&#34;Return 0 as this is not a generator.&#34;&#34;&#34;
        return 0, 0

    def store(self, hour, power):
        &#34;&#34;&#34;Store power.&#34;&#34;&#34;
        assert power &gt; 0, f&#39;{power} is &lt;= 0&#39;

        if self.battery.full_p() or \
           hour % 24 in self.discharge_hours:
            return 0

        power = min(self.charge_capacity(self, hour), power,
                    self.capacity)
        stored = self.battery.charge(power * self.rte)
        if power &gt; 0:
            self.record(hour, stored / self.rte)
        return stored / self.rte

    def reset(self):
        &#34;&#34;&#34;Reset the generator.&#34;&#34;&#34;
        Generator.reset(self)
        Storage.reset(self)
        self.battery.reset()

    def series(self):
        &#34;&#34;&#34;Return the combined series.&#34;&#34;&#34;
        dict1 = Generator.series(self)
        dict2 = Storage.series(self)
        dict1.update(dict2)
        return dict1

    def soc(self):
        &#34;&#34;&#34;Return the battery SOC (state of charge).&#34;&#34;&#34;
        return self.battery.soc()

    # Battery costs are all calculated on the discharge side.
    def capcost(self, costs):
        &#34;&#34;&#34;Return the capital cost.&#34;&#34;&#34;
        return 0

    def fixed_om_costs(self, costs):
        &#34;&#34;&#34;Return the fixed O&amp;M costs.&#34;&#34;&#34;
        return 0

    def opcost_per_mwh(self, costs):
        &#34;&#34;&#34;Return the variable O&amp;M costs.&#34;&#34;&#34;
        return 0

    def summary(self, context):
        &#34;&#34;&#34;Return a summary of the generator activity.&#34;&#34;&#34;
        mwh = self.battery.maxstorage * ureg.MWh
        return Generator.summary(self, context) + \
            f&#39;, charged {thousands(len(self.series_charge))} hours&#39; + \
            f&#39;, {mwh.to_compact()} storage&#39;


class Battery(Generator):
    &#34;&#34;&#34;Battery storage (of any type).&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;#00a2fa&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, polygon, capacity, battery, label=None,
                 discharge_hours=None):
        &#34;&#34;&#34;
        Construct a battery generator.

        battery must be an instance of storage.BatteryStorage.
        discharge_hours is a list of hours when discharging can occur.
        &#34;&#34;&#34;
        if not isinstance(battery, storage.BatteryStorage):
            raise TypeError
        Generator.__init__(self, polygon, capacity, label)
        self.battery = battery
        self.runhours = 0
        self.discharge_hours = discharge_hours \
            if discharge_hours is not None else range(18, 24)

    def step(self, hour, demand):
        &#34;&#34;&#34;Specialised step method for batteries.&#34;&#34;&#34;
        if self.battery.empty_p() or \
           hour % 24 not in self.discharge_hours:
            self.series_power[hour] = 0
            self.series_spilled[hour] = 0
            return 0, 0

        power = min(self.battery.storage, self.capacity, demand)
        self.battery.discharge(power)
        self.series_power[hour] = power
        self.series_spilled[hour] = 0
        if power &gt; 0:
            self.runhours += 1
        return power, 0

    def reset(self):
        &#34;&#34;&#34;Reset the generator.&#34;&#34;&#34;
        Generator.reset(self)
        self.battery.reset()

    def soc(self):
        &#34;&#34;&#34;Return the battery SOC (state of charge).&#34;&#34;&#34;
        return self.battery.soc()

    def capcost(self, costs):
        &#34;&#34;&#34;Return the capital cost.&#34;&#34;&#34;
        kwh = self.battery.maxstorage * 1000
        shours = self.battery.maxstorage / self.capacity
        assert shours in [1, 2, 4, 8]
        cost_per_kwh = costs.totcost_per_kwh[type(self)][shours]
        return kwh * cost_per_kwh

    def fixed_om_costs(self, costs):
        &#34;&#34;&#34;Return the fixed O&amp;M costs.&#34;&#34;&#34;
        return 0

    def opcost_per_mwh(self, costs):
        &#34;&#34;&#34;
        Return the variable O&amp;M costs.

        Per-kWh costs for batteries are included in the capital cost.
        &#34;&#34;&#34;
        return 0

    def summary(self, context):
        &#34;&#34;&#34;Return a summary of the generator activity.&#34;&#34;&#34;
        return Generator.summary(self, context) + \
            f&#39;, ran {thousands(self.runhours)} hours&#39;


class Geothermal(CSVTraceGenerator):
    &#34;&#34;&#34;Geothermal power plant.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;indianred&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def step(self, hour, demand):
        &#34;&#34;&#34;Specialised step method for geothermal generators.

        Geothermal power plants do not spill.
        &#34;&#34;&#34;
        generation = self.generation[hour] * self.capacity
        power = min(generation, demand)
        self.series_power[hour] = power
        self.series_spilled[hour] = 0
        return power, 0


class Geothermal_HSA(Geothermal):
    &#34;&#34;&#34;Hot sedimentary aquifer (HSA) geothermal model.&#34;&#34;&#34;


class Geothermal_EGS(Geothermal):
    &#34;&#34;&#34;Enhanced geothermal systems (EGS) geothermal model.&#34;&#34;&#34;


class DemandResponse(Generator):
    &#34;&#34;&#34;
    Load shedding generator.

    &gt;&gt;&gt; dr = DemandResponse(polygons.WILDCARD, 500, 1500)
    &#34;&#34;&#34;

    patch = Patch(facecolor=&#39;white&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, polygon, capacity, cost_per_mwh, label=None):
        &#34;&#34;&#34;
        Construct a demand response &#39;generator&#39;.

        The demand response opportunity cost is given by
        cost_per_mwh. There is assumed to be no capital cost.
        &#34;&#34;&#34;
        Generator.__init__(self, polygon, capacity, label)
        self.setters = []
        self.runhours = 0
        self.maxresponse = 0
        self.cost_per_mwh = cost_per_mwh

    def step(self, hour, demand):
        &#34;&#34;&#34;
        Specialised step method for demand response.

        &gt;&gt;&gt; dr = DemandResponse(polygons.WILDCARD, 500, 1500)
        &gt;&gt;&gt; dr.step(hour=0, demand=200)
        (200, 0)
        &gt;&gt;&gt; dr.runhours
        1
        &#34;&#34;&#34;
        power = min(self.capacity, demand)
        self.maxresponse = max(self.maxresponse, power)
        self.series_power[hour] = power
        self.series_spilled[hour] = 0
        if power &gt; 0:
            self.runhours += 1
        return power, 0

    def reset(self):
        &#34;&#34;&#34;Reset the generator.&#34;&#34;&#34;
        Generator.reset(self)
        self.runhours = 0
        self.maxresponse = 0

    def opcost_per_mwh(self, costs):
        &#34;&#34;&#34;Return the variable O&amp;M costs.&#34;&#34;&#34;
        return self.cost_per_mwh

    def summary(self, context):
        &#34;&#34;&#34;Return a summary of the generator activity.&#34;&#34;&#34;
        return Generator.summary(self, context) + \
            f&#39;, max response {self.maxresponse} MW&#39; + \
            f&#39;, ran {thousands(self.runhours)} hours&#39;


class Block(Generator):
    &#34;&#34;&#34;A simple block generator.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;darkgreen&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def step(self, hour, demand):
        &#34;&#34;&#34;Step method for GreenPower.&#34;&#34;&#34;
        power = min(self.capacity, demand)
        self.series_power[hour] = power
        self.series_spilled[hour] = 0
        return power, 0


class Electrolyser(Storage, Generator):
    &#34;&#34;&#34;A hydrogen electrolyser.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;teal&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, tank, polygon, capacity, efficiency=0.8, label=None):
        &#34;&#34;&#34;
        Construct a hydrogen electrolyser.

        Arguments include the associated storage vessel (the &#39;tank&#39;),
        the capacity of the electrolyser (in MW) and electrolysis
        conversion efficiency.
        &#34;&#34;&#34;
        if not isinstance(tank, storage.HydrogenStorage):
            raise TypeError
        Storage.__init__(self)
        Generator.__init__(self, polygon, capacity, label)
        self.efficiency = efficiency
        self.tank = tank
        self.setters += [(self.tank.set_storage, 0, 10000)]

    def soc(self):
        &#34;&#34;&#34;Return the hydrogen tank state of charge (SOC).&#34;&#34;&#34;
        return self.tank.soc()

    def series(self):
        &#34;&#34;&#34;Return the combined series.&#34;&#34;&#34;
        dict1 = Generator.series(self)
        dict2 = Storage.series(self)
        dict1.update(dict2)
        return dict1

    def step(self, hour, demand):
        &#34;&#34;&#34;Return 0 as this is not a generator.&#34;&#34;&#34;
        return 0, 0

    def reset(self):
        &#34;&#34;&#34;Reset the generator.&#34;&#34;&#34;
        Storage.reset(self)
        Generator.reset(self)

    def store(self, _, power):
        &#34;&#34;&#34;Store power.&#34;&#34;&#34;
        power = min(power, self.capacity)
        stored = self.tank.charge(power * self.efficiency)
        return stored / self.efficiency


class HydrogenGT(Fuelled):
    &#34;&#34;&#34;A combustion turbine fuelled by hydrogen.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;violet&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, tank, polygon, capacity, efficiency=0.36, label=None):
        &#34;&#34;&#34;
        Construct a HydrogenGT object.

        &gt;&gt;&gt; h = storage.HydrogenStorage(1000, &#39;test&#39;)
        &gt;&gt;&gt; gt = HydrogenGT(h, 1, 100, efficiency=0.5)
        &gt;&gt;&gt; print(gt)
        HydrogenGT (QLD1:1), 100.00 MW
        &gt;&gt;&gt; gt.step(0, 100) # discharge 100 MWh-e of hydrogen
        (100.0, 0)
        &gt;&gt;&gt; gt.step(0, 100) # discharge another 100 MWh-e of hydrogen
        (100.0, 0)
        &gt;&gt;&gt; h.storage == (1000 / 2.) - (200 / gt.efficiency)
        True
        &#34;&#34;&#34;
        assert isinstance(tank, storage.HydrogenStorage)
        Fuelled.__init__(self, polygon, capacity, label)
        self.tank = tank
        self.efficiency = efficiency

    def step(self, hour, demand):
        &#34;&#34;&#34;Step method for hydrogen comubstion turbine generators.&#34;&#34;&#34;
        # calculate hydrogen requirement
        hydrogen = min(self.capacity, demand) / self.efficiency
        # discharge that amount of hydrogen
        power = self.tank.discharge(hydrogen) * self.efficiency
        self.series_power[hour] = power
        self.series_spilled[hour] = 0
        if power &gt; 0:
            self.runhours += 1
        return power, 0

    def capcost(self, costs):
        &#34;&#34;&#34;Return the capital cost (of an OCGT).&#34;&#34;&#34;
        return costs.capcost_per_kw[OCGT] * self.capacity * 1000

    def fixed_om_costs(self, costs):
        &#34;&#34;&#34;Return the fixed O&amp;M costs (of an OCGT).&#34;&#34;&#34;
        return costs.fixed_om_costs[OCGT] * self.capacity * 1000

    def opcost_per_mwh(self, costs):
        &#34;&#34;&#34;Return the variable O&amp;M costs (of an OCGT).&#34;&#34;&#34;
        return costs.opcost_per_mwh[OCGT]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="nemo.generators.Battery"><code class="flex name class">
<span>class <span class="ident">Battery</span></span>
<span>(</span><span>polygon, capacity, battery, label=None, discharge_hours=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Battery storage (of any type).</p>
<p>Construct a battery generator.</p>
<p>battery must be an instance of storage.BatteryStorage.
discharge_hours is a list of hours when discharging can occur.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Battery(Generator):
    &#34;&#34;&#34;Battery storage (of any type).&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;#00a2fa&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, polygon, capacity, battery, label=None,
                 discharge_hours=None):
        &#34;&#34;&#34;
        Construct a battery generator.

        battery must be an instance of storage.BatteryStorage.
        discharge_hours is a list of hours when discharging can occur.
        &#34;&#34;&#34;
        if not isinstance(battery, storage.BatteryStorage):
            raise TypeError
        Generator.__init__(self, polygon, capacity, label)
        self.battery = battery
        self.runhours = 0
        self.discharge_hours = discharge_hours \
            if discharge_hours is not None else range(18, 24)

    def step(self, hour, demand):
        &#34;&#34;&#34;Specialised step method for batteries.&#34;&#34;&#34;
        if self.battery.empty_p() or \
           hour % 24 not in self.discharge_hours:
            self.series_power[hour] = 0
            self.series_spilled[hour] = 0
            return 0, 0

        power = min(self.battery.storage, self.capacity, demand)
        self.battery.discharge(power)
        self.series_power[hour] = power
        self.series_spilled[hour] = 0
        if power &gt; 0:
            self.runhours += 1
        return power, 0

    def reset(self):
        &#34;&#34;&#34;Reset the generator.&#34;&#34;&#34;
        Generator.reset(self)
        self.battery.reset()

    def soc(self):
        &#34;&#34;&#34;Return the battery SOC (state of charge).&#34;&#34;&#34;
        return self.battery.soc()

    def capcost(self, costs):
        &#34;&#34;&#34;Return the capital cost.&#34;&#34;&#34;
        kwh = self.battery.maxstorage * 1000
        shours = self.battery.maxstorage / self.capacity
        assert shours in [1, 2, 4, 8]
        cost_per_kwh = costs.totcost_per_kwh[type(self)][shours]
        return kwh * cost_per_kwh

    def fixed_om_costs(self, costs):
        &#34;&#34;&#34;Return the fixed O&amp;M costs.&#34;&#34;&#34;
        return 0

    def opcost_per_mwh(self, costs):
        &#34;&#34;&#34;
        Return the variable O&amp;M costs.

        Per-kWh costs for batteries are included in the capital cost.
        &#34;&#34;&#34;
        return 0

    def summary(self, context):
        &#34;&#34;&#34;Return a summary of the generator activity.&#34;&#34;&#34;
        return Generator.summary(self, context) + \
            f&#39;, ran {thousands(self.runhours)} hours&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nemo.generators.Battery.patch"><code class="name">var <span class="ident">patch</span></code></dt>
<dd>
<div class="desc"><p>Colour for plotting</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nemo.generators.Battery.opcost_per_mwh"><code class="name flex">
<span>def <span class="ident">opcost_per_mwh</span></span>(<span>self, costs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the variable O&amp;M costs.</p>
<p>Per-kWh costs for batteries are included in the capital cost.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def opcost_per_mwh(self, costs):
    &#34;&#34;&#34;
    Return the variable O&amp;M costs.

    Per-kWh costs for batteries are included in the capital cost.
    &#34;&#34;&#34;
    return 0</code></pre>
</details>
</dd>
<dt id="nemo.generators.Battery.soc"><code class="name flex">
<span>def <span class="ident">soc</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the battery SOC (state of charge).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def soc(self):
    &#34;&#34;&#34;Return the battery SOC (state of charge).&#34;&#34;&#34;
    return self.battery.soc()</code></pre>
</details>
</dd>
<dt id="nemo.generators.Battery.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, hour, demand)</span>
</code></dt>
<dd>
<div class="desc"><p>Specialised step method for batteries.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, hour, demand):
    &#34;&#34;&#34;Specialised step method for batteries.&#34;&#34;&#34;
    if self.battery.empty_p() or \
       hour % 24 not in self.discharge_hours:
        self.series_power[hour] = 0
        self.series_spilled[hour] = 0
        return 0, 0

    power = min(self.battery.storage, self.capacity, demand)
    self.battery.discharge(power)
    self.series_power[hour] = power
    self.series_spilled[hour] = 0
    if power &gt; 0:
        self.runhours += 1
    return power, 0</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.Generator.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.Generator.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.Generator.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.Generator.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.Generator.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.Generator.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.Generator.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.Generator.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.Generator.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.Generator.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.Generator.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.Generator.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.BatteryLoad"><code class="flex name class">
<span>class <span class="ident">BatteryLoad</span></span>
<span>(</span><span>polygon, capacity, battery, label=None, discharge_hours=None, rte=0.95)</span>
</code></dt>
<dd>
<div class="desc"><p>Battery storage (load side).</p>
<p>Construct a battery load (battery charging).</p>
<p>battery must be an instance of storage.BatteryStorage.
discharge_hours is a list of hours when discharging can occur
(or, rather, when charging cannot occur).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BatteryLoad(Storage, Generator):
    &#34;&#34;&#34;Battery storage (load side).&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;#b2daef&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;
    synchronous_p = False
    &#34;&#34;&#34;Is this a synchronous generator?&#34;&#34;&#34;

    def __init__(self, polygon, capacity, battery, label=None,
                 discharge_hours=None, rte=0.95):
        &#34;&#34;&#34;
        Construct a battery load (battery charging).

        battery must be an instance of storage.BatteryStorage.
        discharge_hours is a list of hours when discharging can occur
          (or, rather, when charging cannot occur).
        &#34;&#34;&#34;
        Storage.__init__(self)
        Generator.__init__(self, polygon, capacity, label)
        if not isinstance(battery, storage.BatteryStorage):
            raise TypeError
        self.battery = battery
        self.rte = rte
        shours = battery.maxstorage / capacity
        assert shours in [1, 2, 4, 8]
        self.discharge_hours = discharge_hours \
            if discharge_hours is not None else range(18, 24)

    def step(self, hour, demand):
        &#34;&#34;&#34;Return 0 as this is not a generator.&#34;&#34;&#34;
        return 0, 0

    def store(self, hour, power):
        &#34;&#34;&#34;Store power.&#34;&#34;&#34;
        assert power &gt; 0, f&#39;{power} is &lt;= 0&#39;

        if self.battery.full_p() or \
           hour % 24 in self.discharge_hours:
            return 0

        power = min(self.charge_capacity(self, hour), power,
                    self.capacity)
        stored = self.battery.charge(power * self.rte)
        if power &gt; 0:
            self.record(hour, stored / self.rte)
        return stored / self.rte

    def reset(self):
        &#34;&#34;&#34;Reset the generator.&#34;&#34;&#34;
        Generator.reset(self)
        Storage.reset(self)
        self.battery.reset()

    def series(self):
        &#34;&#34;&#34;Return the combined series.&#34;&#34;&#34;
        dict1 = Generator.series(self)
        dict2 = Storage.series(self)
        dict1.update(dict2)
        return dict1

    def soc(self):
        &#34;&#34;&#34;Return the battery SOC (state of charge).&#34;&#34;&#34;
        return self.battery.soc()

    # Battery costs are all calculated on the discharge side.
    def capcost(self, costs):
        &#34;&#34;&#34;Return the capital cost.&#34;&#34;&#34;
        return 0

    def fixed_om_costs(self, costs):
        &#34;&#34;&#34;Return the fixed O&amp;M costs.&#34;&#34;&#34;
        return 0

    def opcost_per_mwh(self, costs):
        &#34;&#34;&#34;Return the variable O&amp;M costs.&#34;&#34;&#34;
        return 0

    def summary(self, context):
        &#34;&#34;&#34;Return a summary of the generator activity.&#34;&#34;&#34;
        mwh = self.battery.maxstorage * ureg.MWh
        return Generator.summary(self, context) + \
            f&#39;, charged {thousands(len(self.series_charge))} hours&#39; + \
            f&#39;, {mwh.to_compact()} storage&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.Storage" href="#nemo.generators.Storage">Storage</a></li>
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nemo.generators.BatteryLoad.patch"><code class="name">var <span class="ident">patch</span></code></dt>
<dd>
<div class="desc"><p>Colour for plotting</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nemo.generators.BatteryLoad.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset the generator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    &#34;&#34;&#34;Reset the generator.&#34;&#34;&#34;
    Generator.reset(self)
    Storage.reset(self)
    self.battery.reset()</code></pre>
</details>
</dd>
<dt id="nemo.generators.BatteryLoad.series"><code class="name flex">
<span>def <span class="ident">series</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the combined series.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def series(self):
    &#34;&#34;&#34;Return the combined series.&#34;&#34;&#34;
    dict1 = Generator.series(self)
    dict2 = Storage.series(self)
    dict1.update(dict2)
    return dict1</code></pre>
</details>
</dd>
<dt id="nemo.generators.BatteryLoad.soc"><code class="name flex">
<span>def <span class="ident">soc</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the battery SOC (state of charge).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def soc(self):
    &#34;&#34;&#34;Return the battery SOC (state of charge).&#34;&#34;&#34;
    return self.battery.soc()</code></pre>
</details>
</dd>
<dt id="nemo.generators.BatteryLoad.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, hour, demand)</span>
</code></dt>
<dd>
<div class="desc"><p>Return 0 as this is not a generator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, hour, demand):
    &#34;&#34;&#34;Return 0 as this is not a generator.&#34;&#34;&#34;
    return 0, 0</code></pre>
</details>
</dd>
<dt id="nemo.generators.BatteryLoad.store"><code class="name flex">
<span>def <span class="ident">store</span></span>(<span>self, hour, power)</span>
</code></dt>
<dd>
<div class="desc"><p>Store power.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def store(self, hour, power):
    &#34;&#34;&#34;Store power.&#34;&#34;&#34;
    assert power &gt; 0, f&#39;{power} is &lt;= 0&#39;

    if self.battery.full_p() or \
       hour % 24 in self.discharge_hours:
        return 0

    power = min(self.charge_capacity(self, hour), power,
                self.capacity)
    stored = self.battery.charge(power * self.rte)
    if power &gt; 0:
        self.record(hour, stored / self.rte)
    return stored / self.rte</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.Storage" href="#nemo.generators.Storage">Storage</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.Storage.charge_capacity" href="#nemo.generators.Storage.charge_capacity">charge_capacity</a></code></li>
<li><code><a title="nemo.generators.Storage.record" href="#nemo.generators.Storage.record">record</a></code></li>
<li><code><a title="nemo.generators.Storage.storage_p" href="#nemo.generators.Storage.storage_p">storage_p</a></code></li>
</ul>
</li>
<li><code><b><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.Generator.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.Generator.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.Generator.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.Generator.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.Generator.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
<li><code><b><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.Generator.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.Generator.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.Generator.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.Generator.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.Generator.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.Behind_Meter_PV"><code class="flex name class">
<span>class <span class="ident">Behind_Meter_PV</span></span>
<span>(</span><span>polygon, capacity, filename, column, label=None, build_limit=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Behind the meter PV.</p>
<p>Construct a generator with a specified trace file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Behind_Meter_PV(PV):
    &#34;&#34;&#34;Behind the meter PV.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;#ffe03d&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.PV" href="#nemo.generators.PV">PV</a></li>
<li><a title="nemo.generators.CSVTraceGenerator" href="#nemo.generators.CSVTraceGenerator">CSVTraceGenerator</a></li>
<li><a title="nemo.generators.TraceGenerator" href="#nemo.generators.TraceGenerator">TraceGenerator</a></li>
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nemo.generators.Behind_Meter_PV.patch"><code class="name">var <span class="ident">patch</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.PV" href="#nemo.generators.PV">PV</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.PV.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.PV.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.PV.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.PV.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.PV.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.PV.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.PV.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.PV.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.PV.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.PV.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.PV.step" href="#nemo.generators.TraceGenerator.step">step</a></code></li>
<li><code><a title="nemo.generators.PV.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.PV.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.PV.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.Biofuel"><code class="flex name class">
<span>class <span class="ident">Biofuel</span></span>
<span>(</span><span>polygon, capacity, label=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Model of open cycle gas turbines burning biofuel.</p>
<p>Construct a biofuel generator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Biofuel(Fuelled):
    &#34;&#34;&#34;Model of open cycle gas turbines burning biofuel.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;wheat&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, polygon, capacity, label=None):
        &#34;&#34;&#34;Construct a biofuel generator.&#34;&#34;&#34;
        Fuelled.__init__(self, polygon, capacity, label)

    def capcost(self, costs):
        &#34;&#34;&#34;Return the capital cost (of an OCGT).&#34;&#34;&#34;
        return costs.capcost_per_kw[OCGT] * self.capacity * 1000

    def fixed_om_costs(self, costs):
        &#34;&#34;&#34;Return the fixed O&amp;M costs (of an OCGT).&#34;&#34;&#34;
        return costs.fixed_om_costs[OCGT] * self.capacity * 1000

    def opcost_per_mwh(self, costs):
        &#34;&#34;&#34;Return the variable O&amp;M costs.&#34;&#34;&#34;
        vom = costs.opcost_per_mwh[OCGT]
        fuel_cost = costs.bioenergy_price_per_gj * (3.6 / .31)  # 31% heat rate
        return vom + fuel_cost</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.Fuelled" href="#nemo.generators.Fuelled">Fuelled</a></li>
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nemo.generators.Biofuel.patch"><code class="name">var <span class="ident">patch</span></code></dt>
<dd>
<div class="desc"><p>Colour for plotting</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nemo.generators.Biofuel.capcost"><code class="name flex">
<span>def <span class="ident">capcost</span></span>(<span>self, costs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the capital cost (of an OCGT).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def capcost(self, costs):
    &#34;&#34;&#34;Return the capital cost (of an OCGT).&#34;&#34;&#34;
    return costs.capcost_per_kw[OCGT] * self.capacity * 1000</code></pre>
</details>
</dd>
<dt id="nemo.generators.Biofuel.fixed_om_costs"><code class="name flex">
<span>def <span class="ident">fixed_om_costs</span></span>(<span>self, costs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the fixed O&amp;M costs (of an OCGT).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fixed_om_costs(self, costs):
    &#34;&#34;&#34;Return the fixed O&amp;M costs (of an OCGT).&#34;&#34;&#34;
    return costs.fixed_om_costs[OCGT] * self.capacity * 1000</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.Fuelled" href="#nemo.generators.Fuelled">Fuelled</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.Fuelled.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.Fuelled.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.Fuelled.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.Fuelled.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.Fuelled.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.Fuelled.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.Fuelled.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.Fuelled.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.Fuelled.step" href="#nemo.generators.Fuelled.step">step</a></code></li>
<li><code><a title="nemo.generators.Fuelled.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.Fuelled.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.Fuelled.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.Biomass"><code class="flex name class">
<span>class <span class="ident">Biomass</span></span>
<span>(</span><span>polygon, capacity, label=None, heatrate=0.3)</span>
</code></dt>
<dd>
<div class="desc"><p>Model of steam turbine burning solid biomass.</p>
<p>Construct a biomass generator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Biomass(Fuelled):
    &#34;&#34;&#34;Model of steam turbine burning solid biomass.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;#1d7a7a&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, polygon, capacity, label=None, heatrate=0.3):
        &#34;&#34;&#34;Construct a biomass generator.&#34;&#34;&#34;
        Fuelled.__init__(self, polygon, capacity, label)
        self.heatrate = heatrate

    def opcost_per_mwh(self, costs):
        &#34;&#34;&#34;Return the variable O&amp;M costs.&#34;&#34;&#34;
        vom = costs.opcost_per_mwh[type(self)]
        fuel_cost = costs.bioenergy_price_per_gj * (3.6 / self.heatrate)
        return vom + fuel_cost</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.Fuelled" href="#nemo.generators.Fuelled">Fuelled</a></li>
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nemo.generators.Biomass.patch"><code class="name">var <span class="ident">patch</span></code></dt>
<dd>
<div class="desc"><p>Colour for plotting</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.Fuelled" href="#nemo.generators.Fuelled">Fuelled</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.Fuelled.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.Fuelled.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.Fuelled.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.Fuelled.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.Fuelled.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.Fuelled.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.Fuelled.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.Fuelled.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.Fuelled.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.Fuelled.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.Fuelled.step" href="#nemo.generators.Fuelled.step">step</a></code></li>
<li><code><a title="nemo.generators.Fuelled.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.Fuelled.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.Fuelled.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.Black_Coal"><code class="flex name class">
<span>class <span class="ident">Black_Coal</span></span>
<span>(</span><span>polygon, capacity, intensity=0.773, label=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Black coal power stations with no CCS.</p>
<p>Construct a black coal generator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Black_Coal(Fossil):
    &#34;&#34;&#34;Black coal power stations with no CCS.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;#121212&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, polygon, capacity, intensity=0.773, label=None):
        &#34;&#34;&#34;Construct a black coal generator.&#34;&#34;&#34;
        Fossil.__init__(self, polygon, capacity, intensity, label)

    def opcost_per_mwh(self, costs):
        &#34;&#34;&#34;Return the variable O&amp;M costs.&#34;&#34;&#34;
        vom = costs.opcost_per_mwh[type(self)]
        fuel_cost = costs.coal_price_per_gj * 8.57
        total_opcost = vom + fuel_cost + self.intensity * costs.carbon
        return total_opcost</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.Fossil" href="#nemo.generators.Fossil">Fossil</a></li>
<li><a title="nemo.generators.Fuelled" href="#nemo.generators.Fuelled">Fuelled</a></li>
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.Fossil" href="#nemo.generators.Fossil">Fossil</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.Fossil.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.Fossil.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.Fossil.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.Fossil.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.Fossil.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.Fossil.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.Fossil.patch" href="#nemo.generators.Fossil.patch">patch</a></code></li>
<li><code><a title="nemo.generators.Fossil.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.Fossil.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.Fossil.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.Fossil.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.Fossil.step" href="#nemo.generators.Fuelled.step">step</a></code></li>
<li><code><a title="nemo.generators.Fossil.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.Fossil.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.Fossil.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.Block"><code class="flex name class">
<span>class <span class="ident">Block</span></span>
<span>(</span><span>polygon, capacity, label=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A simple block generator.</p>
<p>Construct a base Generator.</p>
<p>Arguments: installed polygon, installed capacity, descriptive label.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Block(Generator):
    &#34;&#34;&#34;A simple block generator.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;darkgreen&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def step(self, hour, demand):
        &#34;&#34;&#34;Step method for GreenPower.&#34;&#34;&#34;
        power = min(self.capacity, demand)
        self.series_power[hour] = power
        self.series_spilled[hour] = 0
        return power, 0</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nemo.generators.Block.patch"><code class="name">var <span class="ident">patch</span></code></dt>
<dd>
<div class="desc"><p>Colour for plotting</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nemo.generators.Block.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, hour, demand)</span>
</code></dt>
<dd>
<div class="desc"><p>Step method for GreenPower.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, hour, demand):
    &#34;&#34;&#34;Step method for GreenPower.&#34;&#34;&#34;
    power = min(self.capacity, demand)
    self.series_power[hour] = power
    self.series_spilled[hour] = 0
    return power, 0</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.Generator.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.Generator.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.Generator.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.Generator.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.Generator.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.Generator.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.Generator.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.Generator.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.Generator.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.Generator.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.Generator.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.Generator.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.Generator.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.CCGT"><code class="flex name class">
<span>class <span class="ident">CCGT</span></span>
<span>(</span><span>polygon, capacity, intensity=0.4, label=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Combined cycle gas turbine (CCGT) model.</p>
<p>Construct a CCGT generator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CCGT(Fossil):
    &#34;&#34;&#34;Combined cycle gas turbine (CCGT) model.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;#fdb462&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, polygon, capacity, intensity=0.4, label=None):
        &#34;&#34;&#34;Construct a CCGT generator.&#34;&#34;&#34;
        Fossil.__init__(self, polygon, capacity, intensity, label)

    def opcost_per_mwh(self, costs):
        &#34;&#34;&#34;Return the variable O&amp;M costs.&#34;&#34;&#34;
        vom = costs.opcost_per_mwh[type(self)]
        fuel_cost = costs.gas_price_per_gj * 6.92
        total_opcost = vom + fuel_cost + self.intensity * costs.carbon
        return total_opcost</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.Fossil" href="#nemo.generators.Fossil">Fossil</a></li>
<li><a title="nemo.generators.Fuelled" href="#nemo.generators.Fuelled">Fuelled</a></li>
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.Fossil" href="#nemo.generators.Fossil">Fossil</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.Fossil.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.Fossil.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.Fossil.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.Fossil.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.Fossil.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.Fossil.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.Fossil.patch" href="#nemo.generators.Fossil.patch">patch</a></code></li>
<li><code><a title="nemo.generators.Fossil.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.Fossil.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.Fossil.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.Fossil.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.Fossil.step" href="#nemo.generators.Fuelled.step">step</a></code></li>
<li><code><a title="nemo.generators.Fossil.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.Fossil.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.Fossil.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.CCGT_CCS"><code class="flex name class">
<span>class <span class="ident">CCGT_CCS</span></span>
<span>(</span><span>polygon, capacity, intensity=0.4, capture=0.85, label=None)</span>
</code></dt>
<dd>
<div class="desc"><p>CCGT with CCS.</p>
<p>Construct a CCGT (with CCS) generator.</p>
<p>Emissions capture rate is given in the range 0 to 1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CCGT_CCS(CCS):
    &#34;&#34;&#34;CCGT with CCS.&#34;&#34;&#34;

    def __init__(self, polygon, capacity, intensity=0.4, capture=0.85,
                 label=None):
        &#34;&#34;&#34;Construct a CCGT (with CCS) generator.

        Emissions capture rate is given in the range 0 to 1.
        &#34;&#34;&#34;
        CCS.__init__(self, polygon, capacity, intensity, capture, label)

    def opcost_per_mwh(self, costs):
        &#34;&#34;&#34;Return the variable O&amp;M costs.&#34;&#34;&#34;
        vom = costs.opcost_per_mwh[type(self)]
        # thermal efficiency 43.1% (AETA 2012)
        fuel_cost = costs.gas_price_per_gj * (3.6 / 0.431)
        total_opcost = vom + fuel_cost + \
            (self.intensity * (1 - self.capture) * costs.carbon) + \
            (self.intensity * self.capture * costs.ccs_storage_per_t)
        return total_opcost</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.CCS" href="#nemo.generators.CCS">CCS</a></li>
<li><a title="nemo.generators.Fossil" href="#nemo.generators.Fossil">Fossil</a></li>
<li><a title="nemo.generators.Fuelled" href="#nemo.generators.Fuelled">Fuelled</a></li>
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.CCS" href="#nemo.generators.CCS">CCS</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.CCS.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.CCS.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.CCS.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.CCS.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.CCS.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.CCS.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.CCS.patch" href="#nemo.generators.Fossil.patch">patch</a></code></li>
<li><code><a title="nemo.generators.CCS.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.CCS.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.CCS.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.CCS.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.CCS.step" href="#nemo.generators.Fuelled.step">step</a></code></li>
<li><code><a title="nemo.generators.CCS.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.CCS.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.CCS.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.CCS"><code class="flex name class">
<span>class <span class="ident">CCS</span></span>
<span>(</span><span>polygon, capacity, intensity, capture, label=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class of carbon capture and storage (CCS).</p>
<p>Construct a CCS generator.</p>
<p>Emissions capture rate is given in the range 0 to 1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CCS(Fossil):
    &#34;&#34;&#34;Base class of carbon capture and storage (CCS).&#34;&#34;&#34;

    def __init__(self, polygon, capacity, intensity, capture, label=None):
        &#34;&#34;&#34;Construct a CCS generator.

        Emissions capture rate is given in the range 0 to 1.
        &#34;&#34;&#34;
        Fossil.__init__(self, polygon, capacity, intensity, label)
        assert 0 &lt;= capture &lt;= 1
        self.capture = capture

    def summary(self, context):
        &#34;&#34;&#34;Return a summary of the generator activity.&#34;&#34;&#34;
        generation = sum(self.series_power.values()) * ureg.MWh
        emissions = generation * self.intensity * (ureg.t / ureg.MWh)
        captured = emissions * self.capture
        return Fossil.summary(self, context) + \
            f&#39;, {captured.to(&#34;Mt&#34;)} captured&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.Fossil" href="#nemo.generators.Fossil">Fossil</a></li>
<li><a title="nemo.generators.Fuelled" href="#nemo.generators.Fuelled">Fuelled</a></li>
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="nemo.generators.CCGT_CCS" href="#nemo.generators.CCGT_CCS">CCGT_CCS</a></li>
<li><a title="nemo.generators.Coal_CCS" href="#nemo.generators.Coal_CCS">Coal_CCS</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.Fossil" href="#nemo.generators.Fossil">Fossil</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.Fossil.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.Fossil.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.Fossil.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.Fossil.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.Fossil.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.Fossil.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.Fossil.patch" href="#nemo.generators.Fossil.patch">patch</a></code></li>
<li><code><a title="nemo.generators.Fossil.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.Fossil.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.Fossil.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.Fossil.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.Fossil.step" href="#nemo.generators.Fuelled.step">step</a></code></li>
<li><code><a title="nemo.generators.Fossil.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.Fossil.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.Fossil.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.CST"><code class="flex name class">
<span>class <span class="ident">CST</span></span>
<span>(</span><span>polygon, capacity, solarmult, shours, filename, column, label=None, build_limit=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Concentrating solar thermal (CST) model.</p>
<p>Construct a CST generator.</p>
<p>Arguments include capacity (in MW), sm (solar multiple) and
shours (hours of storage).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CST(CSVTraceGenerator):
    &#34;&#34;&#34;Concentrating solar thermal (CST) model.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;orange&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, polygon, capacity, solarmult, shours, filename,
                 column, label=None, build_limit=None):
        &#34;&#34;&#34;
        Construct a CST generator.

        Arguments include capacity (in MW), sm (solar multiple) and
        shours (hours of storage).
        &#34;&#34;&#34;
        CSVTraceGenerator.__init__(self, polygon, capacity, filename, column,
                                   label)
        self.maxstorage = None
        self.stored = None
        self.set_storage(shours)
        self.set_multiple(solarmult)

    def set_capacity(self, cap):
        &#34;&#34;&#34;Change the capacity of the generator to cap GW.&#34;&#34;&#34;
        Generator.set_capacity(self, cap)
        self.maxstorage = self.capacity * self.shours

    def set_multiple(self, solarmult):
        &#34;&#34;&#34;Change the solar multiple of a CST plant.&#34;&#34;&#34;
        self.solarmult = solarmult

    def set_storage(self, shours):
        &#34;&#34;&#34;Change the storage capacity of a CST plant.&#34;&#34;&#34;
        self.shours = shours
        self.maxstorage = self.capacity * shours
        self.stored = 0.5 * self.maxstorage

    def step(self, hour, demand):
        &#34;&#34;&#34;Step method for CST generators.&#34;&#34;&#34;
        generation = self.generation[hour] * self.capacity * self.solarmult
        remainder = min(self.capacity, demand)
        if generation &gt; remainder:
            to_storage = generation - remainder
            generation -= to_storage
            self.stored += to_storage
            self.stored = min(self.stored, self.maxstorage)
        else:
            from_storage = min(remainder - generation, self.stored)
            generation += from_storage
            self.stored -= from_storage
            assert self.stored &gt;= 0
        assert self.stored &lt;= self.maxstorage
        assert self.stored &gt;= 0
        self.series_power[hour] = generation
        self.series_spilled[hour] = 0

        # This can happen due to rounding errors.
        generation = min(generation, demand)
        return generation, 0

    def reset(self):
        &#34;&#34;&#34;Reset the generator.&#34;&#34;&#34;
        Generator.reset(self)
        self.stored = 0.5 * self.maxstorage

    def summary(self, context):
        &#34;&#34;&#34;Return a summary of the generator activity.&#34;&#34;&#34;
        return Generator.summary(self, context) + \
            f&#39;, solar mult {self.solarmult:.2f}&#39; + \
            f&#39;, {self.shours}h storage&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.CSVTraceGenerator" href="#nemo.generators.CSVTraceGenerator">CSVTraceGenerator</a></li>
<li><a title="nemo.generators.TraceGenerator" href="#nemo.generators.TraceGenerator">TraceGenerator</a></li>
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="nemo.generators.CentralReceiver" href="#nemo.generators.CentralReceiver">CentralReceiver</a></li>
<li><a title="nemo.generators.ParabolicTrough" href="#nemo.generators.ParabolicTrough">ParabolicTrough</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nemo.generators.CST.patch"><code class="name">var <span class="ident">patch</span></code></dt>
<dd>
<div class="desc"><p>Colour for plotting</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nemo.generators.CST.set_multiple"><code class="name flex">
<span>def <span class="ident">set_multiple</span></span>(<span>self, solarmult)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the solar multiple of a CST plant.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_multiple(self, solarmult):
    &#34;&#34;&#34;Change the solar multiple of a CST plant.&#34;&#34;&#34;
    self.solarmult = solarmult</code></pre>
</details>
</dd>
<dt id="nemo.generators.CST.set_storage"><code class="name flex">
<span>def <span class="ident">set_storage</span></span>(<span>self, shours)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the storage capacity of a CST plant.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_storage(self, shours):
    &#34;&#34;&#34;Change the storage capacity of a CST plant.&#34;&#34;&#34;
    self.shours = shours
    self.maxstorage = self.capacity * shours
    self.stored = 0.5 * self.maxstorage</code></pre>
</details>
</dd>
<dt id="nemo.generators.CST.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, hour, demand)</span>
</code></dt>
<dd>
<div class="desc"><p>Step method for CST generators.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, hour, demand):
    &#34;&#34;&#34;Step method for CST generators.&#34;&#34;&#34;
    generation = self.generation[hour] * self.capacity * self.solarmult
    remainder = min(self.capacity, demand)
    if generation &gt; remainder:
        to_storage = generation - remainder
        generation -= to_storage
        self.stored += to_storage
        self.stored = min(self.stored, self.maxstorage)
    else:
        from_storage = min(remainder - generation, self.stored)
        generation += from_storage
        self.stored -= from_storage
        assert self.stored &gt;= 0
    assert self.stored &lt;= self.maxstorage
    assert self.stored &gt;= 0
    self.series_power[hour] = generation
    self.series_spilled[hour] = 0

    # This can happen due to rounding errors.
    generation = min(generation, demand)
    return generation, 0</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.CSVTraceGenerator" href="#nemo.generators.CSVTraceGenerator">CSVTraceGenerator</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.CSVTraceGenerator.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.CSVTraceGenerator"><code class="flex name class">
<span>class <span class="ident">CSVTraceGenerator</span></span>
<span>(</span><span>polygon, capacity, filename, column, label=None, build_limit=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A generator that gets its hourly dispatch from a CSV trace file.</p>
<p>Construct a generator with a specified trace file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CSVTraceGenerator(TraceGenerator):
    &#34;&#34;&#34;A generator that gets its hourly dispatch from a CSV trace file.&#34;&#34;&#34;

    csvfilename = None
    csvdata = None

    def __init__(self, polygon, capacity, filename, column, label=None,
                 build_limit=None):
        &#34;&#34;&#34;Construct a generator with a specified trace file.&#34;&#34;&#34;
        TraceGenerator.__init__(self, polygon, capacity, label, build_limit)
        cls = self.__class__
        if cls.csvfilename != filename:
            # Optimisation:
            # Only if the filename changes do we invoke genfromtxt.
            if not filename.startswith(&#39;http&#39;):
                # Local file path
                traceinput = filename
            else:
                try:
                    resp = requests.request(&#39;GET&#39;, filename, timeout=5)
                except requests.exceptions.Timeout as exc:
                    raise TimeoutError(f&#39;timeout fetching {filename}&#39;) from exc
                if not resp.ok:
                    msg = f&#39;HTTP {resp.status_code}: {filename}&#39;
                    raise ConnectionError(msg)
                traceinput = resp.text.splitlines()
            cls.csvdata = np.genfromtxt(traceinput, encoding=&#39;UTF-8&#39;,
                                        delimiter=&#39;,&#39;)
            cls.csvdata = np.maximum(0, cls.csvdata)
            # check all elements are not NaNs
            assert np.all(~np.isnan(cls.csvdata)), \
                f&#39;Trace file {filename} contains NaNs; inspect file&#39;
            cls.csvfilename = filename
        self.generation = cls.csvdata[::, column]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.TraceGenerator" href="#nemo.generators.TraceGenerator">TraceGenerator</a></li>
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="nemo.generators.CST" href="#nemo.generators.CST">CST</a></li>
<li><a title="nemo.generators.Geothermal" href="#nemo.generators.Geothermal">Geothermal</a></li>
<li><a title="nemo.generators.PV" href="#nemo.generators.PV">PV</a></li>
<li><a title="nemo.generators.Wind" href="#nemo.generators.Wind">Wind</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nemo.generators.CSVTraceGenerator.csvdata"><code class="name">var <span class="ident">csvdata</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nemo.generators.CSVTraceGenerator.csvfilename"><code class="name">var <span class="ident">csvfilename</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.TraceGenerator" href="#nemo.generators.TraceGenerator">TraceGenerator</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.TraceGenerator.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.TraceGenerator.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.TraceGenerator.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.TraceGenerator.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.TraceGenerator.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.TraceGenerator.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.TraceGenerator.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.TraceGenerator.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.TraceGenerator.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.TraceGenerator.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.TraceGenerator.step" href="#nemo.generators.TraceGenerator.step">step</a></code></li>
<li><code><a title="nemo.generators.TraceGenerator.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.TraceGenerator.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.TraceGenerator.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.CentralReceiver"><code class="flex name class">
<span>class <span class="ident">CentralReceiver</span></span>
<span>(</span><span>polygon, capacity, solarmult, shours, filename, column, label=None, build_limit=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Central receiver CST generator.</p>
<p>This stub class allows differentiated CST costs in costs.py.</p>
<p>Construct a CST generator.</p>
<p>Arguments include capacity (in MW), sm (solar multiple) and
shours (hours of storage).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CentralReceiver(CST):
    &#34;&#34;&#34;Central receiver CST generator.

    This stub class allows differentiated CST costs in costs.py.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.CST" href="#nemo.generators.CST">CST</a></li>
<li><a title="nemo.generators.CSVTraceGenerator" href="#nemo.generators.CSVTraceGenerator">CSVTraceGenerator</a></li>
<li><a title="nemo.generators.TraceGenerator" href="#nemo.generators.TraceGenerator">TraceGenerator</a></li>
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.CST" href="#nemo.generators.CST">CST</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.CST.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.CST.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.CST.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.CST.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.CST.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.CST.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.CST.patch" href="#nemo.generators.CST.patch">patch</a></code></li>
<li><code><a title="nemo.generators.CST.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.CST.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.CST.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.CST.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.CST.set_multiple" href="#nemo.generators.CST.set_multiple">set_multiple</a></code></li>
<li><code><a title="nemo.generators.CST.set_storage" href="#nemo.generators.CST.set_storage">set_storage</a></code></li>
<li><code><a title="nemo.generators.CST.step" href="#nemo.generators.CST.step">step</a></code></li>
<li><code><a title="nemo.generators.CST.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.CST.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.CST.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.Coal_CCS"><code class="flex name class">
<span>class <span class="ident">Coal_CCS</span></span>
<span>(</span><span>polygon, capacity, intensity=0.8, capture=0.85, label=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Coal with CCS.</p>
<p>Construct a coal CCS generator.</p>
<p>Emissions capture rate is given in the range 0 to 1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Coal_CCS(CCS):
    &#34;&#34;&#34;Coal with CCS.&#34;&#34;&#34;

    def __init__(self, polygon, capacity, intensity=0.8, capture=0.85,
                 label=None):
        &#34;&#34;&#34;Construct a coal CCS generator.

        Emissions capture rate is given in the range 0 to 1.
        &#34;&#34;&#34;
        CCS.__init__(self, polygon, capacity, intensity, capture, label)

    def opcost_per_mwh(self, costs):
        &#34;&#34;&#34;Return the variable O&amp;M costs.&#34;&#34;&#34;
        vom = costs.opcost_per_mwh[type(self)]
        # thermal efficiency 31.4% (AETA 2012)
        fuel_cost = costs.coal_price_per_gj * (3.6 / 0.314)
        # t CO2/MWh
        emissions_rate = 0.103
        total_opcost = vom + fuel_cost + \
            (emissions_rate * costs.carbon) + \
            (self.intensity * self.capture * costs.ccs_storage_per_t)
        return total_opcost</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.CCS" href="#nemo.generators.CCS">CCS</a></li>
<li><a title="nemo.generators.Fossil" href="#nemo.generators.Fossil">Fossil</a></li>
<li><a title="nemo.generators.Fuelled" href="#nemo.generators.Fuelled">Fuelled</a></li>
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.CCS" href="#nemo.generators.CCS">CCS</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.CCS.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.CCS.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.CCS.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.CCS.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.CCS.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.CCS.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.CCS.patch" href="#nemo.generators.Fossil.patch">patch</a></code></li>
<li><code><a title="nemo.generators.CCS.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.CCS.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.CCS.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.CCS.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.CCS.step" href="#nemo.generators.Fuelled.step">step</a></code></li>
<li><code><a title="nemo.generators.CCS.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.CCS.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.CCS.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.DemandResponse"><code class="flex name class">
<span>class <span class="ident">DemandResponse</span></span>
<span>(</span><span>polygon, capacity, cost_per_mwh, label=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Load shedding generator.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; dr = DemandResponse(polygons.WILDCARD, 500, 1500)
</code></pre>
<p>Construct a demand response 'generator'.</p>
<p>The demand response opportunity cost is given by
cost_per_mwh. There is assumed to be no capital cost.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DemandResponse(Generator):
    &#34;&#34;&#34;
    Load shedding generator.

    &gt;&gt;&gt; dr = DemandResponse(polygons.WILDCARD, 500, 1500)
    &#34;&#34;&#34;

    patch = Patch(facecolor=&#39;white&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, polygon, capacity, cost_per_mwh, label=None):
        &#34;&#34;&#34;
        Construct a demand response &#39;generator&#39;.

        The demand response opportunity cost is given by
        cost_per_mwh. There is assumed to be no capital cost.
        &#34;&#34;&#34;
        Generator.__init__(self, polygon, capacity, label)
        self.setters = []
        self.runhours = 0
        self.maxresponse = 0
        self.cost_per_mwh = cost_per_mwh

    def step(self, hour, demand):
        &#34;&#34;&#34;
        Specialised step method for demand response.

        &gt;&gt;&gt; dr = DemandResponse(polygons.WILDCARD, 500, 1500)
        &gt;&gt;&gt; dr.step(hour=0, demand=200)
        (200, 0)
        &gt;&gt;&gt; dr.runhours
        1
        &#34;&#34;&#34;
        power = min(self.capacity, demand)
        self.maxresponse = max(self.maxresponse, power)
        self.series_power[hour] = power
        self.series_spilled[hour] = 0
        if power &gt; 0:
            self.runhours += 1
        return power, 0

    def reset(self):
        &#34;&#34;&#34;Reset the generator.&#34;&#34;&#34;
        Generator.reset(self)
        self.runhours = 0
        self.maxresponse = 0

    def opcost_per_mwh(self, costs):
        &#34;&#34;&#34;Return the variable O&amp;M costs.&#34;&#34;&#34;
        return self.cost_per_mwh

    def summary(self, context):
        &#34;&#34;&#34;Return a summary of the generator activity.&#34;&#34;&#34;
        return Generator.summary(self, context) + \
            f&#39;, max response {self.maxresponse} MW&#39; + \
            f&#39;, ran {thousands(self.runhours)} hours&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nemo.generators.DemandResponse.patch"><code class="name">var <span class="ident">patch</span></code></dt>
<dd>
<div class="desc"><p>Colour for plotting</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nemo.generators.DemandResponse.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, hour, demand)</span>
</code></dt>
<dd>
<div class="desc"><p>Specialised step method for demand response.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; dr = DemandResponse(polygons.WILDCARD, 500, 1500)
&gt;&gt;&gt; dr.step(hour=0, demand=200)
(200, 0)
&gt;&gt;&gt; dr.runhours
1
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, hour, demand):
    &#34;&#34;&#34;
    Specialised step method for demand response.

    &gt;&gt;&gt; dr = DemandResponse(polygons.WILDCARD, 500, 1500)
    &gt;&gt;&gt; dr.step(hour=0, demand=200)
    (200, 0)
    &gt;&gt;&gt; dr.runhours
    1
    &#34;&#34;&#34;
    power = min(self.capacity, demand)
    self.maxresponse = max(self.maxresponse, power)
    self.series_power[hour] = power
    self.series_spilled[hour] = 0
    if power &gt; 0:
        self.runhours += 1
    return power, 0</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.Generator.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.Generator.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.Generator.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.Generator.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.Generator.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.Generator.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.Generator.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.Generator.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.Generator.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.Generator.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.Generator.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.Generator.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.Generator.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.Diesel"><code class="flex name class">
<span>class <span class="ident">Diesel</span></span>
<span>(</span><span>polygon, capacity, intensity=1.0, kwh_per_litre=3.3, label=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Diesel genset model.</p>
<p>Construct a diesel generator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Diesel(Fossil):
    &#34;&#34;&#34;Diesel genset model.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;#f35020&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, polygon, capacity, intensity=1.0, kwh_per_litre=3.3,
                 label=None):
        &#34;&#34;&#34;Construct a diesel generator.&#34;&#34;&#34;
        Fossil.__init__(self, polygon, capacity, intensity, label)
        self.kwh_per_litre = kwh_per_litre

    def opcost_per_mwh(self, costs):
        &#34;&#34;&#34;Return the variable O&amp;M costs.&#34;&#34;&#34;
        vom = costs.opcost_per_mwh[type(self)]
        litres_per_mwh = (1 / self.kwh_per_litre) * 1000
        fuel_cost = costs.diesel_price_per_litre * litres_per_mwh
        total_opcost = vom + fuel_cost + self.intensity * costs.carbon
        return total_opcost</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.Fossil" href="#nemo.generators.Fossil">Fossil</a></li>
<li><a title="nemo.generators.Fuelled" href="#nemo.generators.Fuelled">Fuelled</a></li>
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.Fossil" href="#nemo.generators.Fossil">Fossil</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.Fossil.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.Fossil.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.Fossil.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.Fossil.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.Fossil.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.Fossil.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.Fossil.patch" href="#nemo.generators.Fossil.patch">patch</a></code></li>
<li><code><a title="nemo.generators.Fossil.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.Fossil.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.Fossil.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.Fossil.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.Fossil.step" href="#nemo.generators.Fuelled.step">step</a></code></li>
<li><code><a title="nemo.generators.Fossil.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.Fossil.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.Fossil.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.Electrolyser"><code class="flex name class">
<span>class <span class="ident">Electrolyser</span></span>
<span>(</span><span>tank, polygon, capacity, efficiency=0.8, label=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A hydrogen electrolyser.</p>
<p>Construct a hydrogen electrolyser.</p>
<p>Arguments include the associated storage vessel (the 'tank'),
the capacity of the electrolyser (in MW) and electrolysis
conversion efficiency.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Electrolyser(Storage, Generator):
    &#34;&#34;&#34;A hydrogen electrolyser.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;teal&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, tank, polygon, capacity, efficiency=0.8, label=None):
        &#34;&#34;&#34;
        Construct a hydrogen electrolyser.

        Arguments include the associated storage vessel (the &#39;tank&#39;),
        the capacity of the electrolyser (in MW) and electrolysis
        conversion efficiency.
        &#34;&#34;&#34;
        if not isinstance(tank, storage.HydrogenStorage):
            raise TypeError
        Storage.__init__(self)
        Generator.__init__(self, polygon, capacity, label)
        self.efficiency = efficiency
        self.tank = tank
        self.setters += [(self.tank.set_storage, 0, 10000)]

    def soc(self):
        &#34;&#34;&#34;Return the hydrogen tank state of charge (SOC).&#34;&#34;&#34;
        return self.tank.soc()

    def series(self):
        &#34;&#34;&#34;Return the combined series.&#34;&#34;&#34;
        dict1 = Generator.series(self)
        dict2 = Storage.series(self)
        dict1.update(dict2)
        return dict1

    def step(self, hour, demand):
        &#34;&#34;&#34;Return 0 as this is not a generator.&#34;&#34;&#34;
        return 0, 0

    def reset(self):
        &#34;&#34;&#34;Reset the generator.&#34;&#34;&#34;
        Storage.reset(self)
        Generator.reset(self)

    def store(self, _, power):
        &#34;&#34;&#34;Store power.&#34;&#34;&#34;
        power = min(power, self.capacity)
        stored = self.tank.charge(power * self.efficiency)
        return stored / self.efficiency</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.Storage" href="#nemo.generators.Storage">Storage</a></li>
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nemo.generators.Electrolyser.patch"><code class="name">var <span class="ident">patch</span></code></dt>
<dd>
<div class="desc"><p>Colour for plotting</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nemo.generators.Electrolyser.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset the generator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    &#34;&#34;&#34;Reset the generator.&#34;&#34;&#34;
    Storage.reset(self)
    Generator.reset(self)</code></pre>
</details>
</dd>
<dt id="nemo.generators.Electrolyser.series"><code class="name flex">
<span>def <span class="ident">series</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the combined series.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def series(self):
    &#34;&#34;&#34;Return the combined series.&#34;&#34;&#34;
    dict1 = Generator.series(self)
    dict2 = Storage.series(self)
    dict1.update(dict2)
    return dict1</code></pre>
</details>
</dd>
<dt id="nemo.generators.Electrolyser.soc"><code class="name flex">
<span>def <span class="ident">soc</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the hydrogen tank state of charge (SOC).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def soc(self):
    &#34;&#34;&#34;Return the hydrogen tank state of charge (SOC).&#34;&#34;&#34;
    return self.tank.soc()</code></pre>
</details>
</dd>
<dt id="nemo.generators.Electrolyser.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, hour, demand)</span>
</code></dt>
<dd>
<div class="desc"><p>Return 0 as this is not a generator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, hour, demand):
    &#34;&#34;&#34;Return 0 as this is not a generator.&#34;&#34;&#34;
    return 0, 0</code></pre>
</details>
</dd>
<dt id="nemo.generators.Electrolyser.store"><code class="name flex">
<span>def <span class="ident">store</span></span>(<span>self, _, power)</span>
</code></dt>
<dd>
<div class="desc"><p>Store power.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def store(self, _, power):
    &#34;&#34;&#34;Store power.&#34;&#34;&#34;
    power = min(power, self.capacity)
    stored = self.tank.charge(power * self.efficiency)
    return stored / self.efficiency</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.Storage" href="#nemo.generators.Storage">Storage</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.Storage.charge_capacity" href="#nemo.generators.Storage.charge_capacity">charge_capacity</a></code></li>
<li><code><a title="nemo.generators.Storage.record" href="#nemo.generators.Storage.record">record</a></code></li>
<li><code><a title="nemo.generators.Storage.storage_p" href="#nemo.generators.Storage.storage_p">storage_p</a></code></li>
</ul>
</li>
<li><code><b><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.Generator.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.Generator.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.Generator.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.Generator.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.Generator.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.Generator.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.Generator.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.Generator.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.Generator.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.Generator.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.Fossil"><code class="flex name class">
<span>class <span class="ident">Fossil</span></span>
<span>(</span><span>polygon, capacity, intensity, label=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for GHG emitting power stations.</p>
<p>Construct a fossil fuelled generator.</p>
<p>Greenhouse gas emissions intensity is given in tonnes per MWh.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Fossil(Fuelled):
    &#34;&#34;&#34;Base class for GHG emitting power stations.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;grey&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, polygon, capacity, intensity, label=None):
        &#34;&#34;&#34;
        Construct a fossil fuelled generator.

        Greenhouse gas emissions intensity is given in tonnes per MWh.
        &#34;&#34;&#34;
        Fuelled.__init__(self, polygon, capacity, label)
        self.intensity = intensity

    def summary(self, context):
        &#34;&#34;&#34;Return a summary of the generator activity.&#34;&#34;&#34;
        generation = sum(self.series_power.values()) * ureg.MWh
        emissions = generation * self.intensity * (ureg.t / ureg.MWh)
        return Fuelled.summary(self, context) + \
            f&#39;, {emissions.to(&#34;Mt&#34;)} CO2&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.Fuelled" href="#nemo.generators.Fuelled">Fuelled</a></li>
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="nemo.generators.Black_Coal" href="#nemo.generators.Black_Coal">Black_Coal</a></li>
<li><a title="nemo.generators.CCGT" href="#nemo.generators.CCGT">CCGT</a></li>
<li><a title="nemo.generators.CCS" href="#nemo.generators.CCS">CCS</a></li>
<li><a title="nemo.generators.Diesel" href="#nemo.generators.Diesel">Diesel</a></li>
<li><a title="nemo.generators.OCGT" href="#nemo.generators.OCGT">OCGT</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nemo.generators.Fossil.patch"><code class="name">var <span class="ident">patch</span></code></dt>
<dd>
<div class="desc"><p>Colour for plotting</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.Fuelled" href="#nemo.generators.Fuelled">Fuelled</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.Fuelled.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.Fuelled.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.Fuelled.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.Fuelled.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.Fuelled.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.Fuelled.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.Fuelled.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.Fuelled.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.Fuelled.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.Fuelled.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.Fuelled.step" href="#nemo.generators.Fuelled.step">step</a></code></li>
<li><code><a title="nemo.generators.Fuelled.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.Fuelled.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.Fuelled.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.Fuelled"><code class="flex name class">
<span>class <span class="ident">Fuelled</span></span>
<span>(</span><span>polygon, capacity, label)</span>
</code></dt>
<dd>
<div class="desc"><p>The class of generators that consume fuel.</p>
<p>Construct a fuelled generator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Fuelled(Generator):
    &#34;&#34;&#34;The class of generators that consume fuel.&#34;&#34;&#34;

    def __init__(self, polygon, capacity, label):
        &#34;&#34;&#34;Construct a fuelled generator.&#34;&#34;&#34;
        Generator.__init__(self, polygon, capacity, label)
        self.runhours = 0

    def reset(self):
        &#34;&#34;&#34;Reset the generator.&#34;&#34;&#34;
        Generator.reset(self)
        self.runhours = 0

    def step(self, hour, demand):
        &#34;&#34;&#34;Step method for fuelled generators.&#34;&#34;&#34;
        power = min(self.capacity, demand)
        if power &gt; 0:
            self.runhours += 1
        self.series_power[hour] = power
        self.series_spilled[hour] = 0
        return power, 0

    def summary(self, context):
        &#34;&#34;&#34;Return a summary of the generator activity.&#34;&#34;&#34;
        return Generator.summary(self, context) + \
            f&#39;, ran {thousands(self.runhours)} hours&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="nemo.generators.Biofuel" href="#nemo.generators.Biofuel">Biofuel</a></li>
<li><a title="nemo.generators.Biomass" href="#nemo.generators.Biomass">Biomass</a></li>
<li><a title="nemo.generators.Fossil" href="#nemo.generators.Fossil">Fossil</a></li>
<li><a title="nemo.generators.Hydro" href="#nemo.generators.Hydro">Hydro</a></li>
<li><a title="nemo.generators.HydrogenGT" href="#nemo.generators.HydrogenGT">HydrogenGT</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="nemo.generators.Fuelled.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, hour, demand)</span>
</code></dt>
<dd>
<div class="desc"><p>Step method for fuelled generators.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, hour, demand):
    &#34;&#34;&#34;Step method for fuelled generators.&#34;&#34;&#34;
    power = min(self.capacity, demand)
    if power &gt; 0:
        self.runhours += 1
    self.series_power[hour] = power
    self.series_spilled[hour] = 0
    return power, 0</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.Generator.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.Generator.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.Generator.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.Generator.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.Generator.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.Generator.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.Generator.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.Generator.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.Generator.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.Generator.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.Generator.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.Generator.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.Generator.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.Generator"><code class="flex name class">
<span>class <span class="ident">Generator</span></span>
<span>(</span><span>polygon, capacity, label=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base generator class.</p>
<p>Construct a base Generator.</p>
<p>Arguments: installed polygon, installed capacity, descriptive label.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Generator():
    &#34;&#34;&#34;Base generator class.&#34;&#34;&#34;

    # Is the generator a rotating machine?
    synchronous_p = True
    &#34;&#34;&#34;Is this a synchronous generator?&#34;&#34;&#34;

    storage_p = False
    &#34;&#34;&#34;A generator is not capable of storage by default.&#34;&#34;&#34;

    def __init__(self, polygon, capacity, label=None):
        &#34;&#34;&#34;
        Construct a base Generator.

        Arguments: installed polygon, installed capacity, descriptive label.
        &#34;&#34;&#34;
        assert capacity &gt;= 0
        self.setters = [(self.set_capacity, 0, 40)]
        self.label = self.__class__.__name__ if label is None else label
        self.capacity = capacity
        self.polygon = polygon

        # Sanity check polygon argument.
        assert not isinstance(polygon, polygons.regions.Region)
        assert 0 &lt; polygon &lt;= polygons.NUMPOLYGONS, polygon

        # Time series of dispatched power and spills
        self.series_power = {}
        self.series_spilled = {}

    def series(self):
        &#34;&#34;&#34;Return generation and spills series.&#34;&#34;&#34;
        return {&#39;power&#39;: pd.Series(self.series_power, dtype=float),
                &#39;spilled&#39;: pd.Series(self.series_spilled, dtype=float)}

    def step(self, hour, demand):
        &#34;&#34;&#34;Step the generator by one hour.&#34;&#34;&#34;
        raise NotImplementedError

    def region(self):
        &#34;&#34;&#34;Return the region the generator is in.&#34;&#34;&#34;
        return polygons.region(self.polygon)

    def capcost(self, costs):
        &#34;&#34;&#34;Return the capital cost.&#34;&#34;&#34;
        return costs.capcost_per_kw[type(self)] * self.capacity * 1000

    def opcost(self, costs):
        &#34;&#34;&#34;Return the annual operating and maintenance cost.&#34;&#34;&#34;
        return self.fixed_om_costs(costs) + \
            sum(self.series_power.values()) * self.opcost_per_mwh(costs)

    def fixed_om_costs(self, costs):
        &#34;&#34;&#34;Return the fixed O&amp;M costs.&#34;&#34;&#34;
        return costs.fixed_om_costs[type(self)] * self.capacity * 1000

    def opcost_per_mwh(self, costs):
        &#34;&#34;&#34;Return the variable O&amp;M costs.&#34;&#34;&#34;
        return costs.opcost_per_mwh[type(self)]

    def reset(self):
        &#34;&#34;&#34;Reset the generator.&#34;&#34;&#34;
        self.series_power.clear()
        self.series_spilled.clear()

    def capfactor(self):
        &#34;&#34;&#34;Capacity factor of this generator (in %).&#34;&#34;&#34;
        supplied = sum(self.series_power.values())
        hours = len(self.series_power)
        try:
            capfactor = supplied / (self.capacity * hours) * 100
            return capfactor
        except ZeroDivisionError:
            return float(&#39;nan&#39;)

    def lcoe(self, costs, years):
        &#34;&#34;&#34;Calculate the LCOE in $/MWh.&#34;&#34;&#34;
        total_cost = self.capcost(costs) / costs.annuityf * years \
            + self.opcost(costs)
        supplied = sum(self.series_power.values())
        if supplied &gt; 0:
            cost_per_mwh = total_cost / supplied
            return cost_per_mwh
        return np.inf

    def summary(self, context):
        &#34;&#34;&#34;Return a summary of the generator activity.&#34;&#34;&#34;
        costs = context.costs
        supplied = sum(self.series_power.values()) * ureg.MWh
        string = f&#39;supplied {supplied.to_compact()}&#39;
        if self.capacity &gt; 0:
            if self.capfactor() &gt; 0:
                string += f&#39;, CF {self.capfactor():.1f}%&#39;
        if sum(self.series_spilled.values()) &gt; 0:
            spilled = sum(self.series_spilled.values()) * ureg.MWh
            string += f&#39;, surplus {spilled.to_compact()}&#39;
        if self.capcost(costs) &gt; 0:
            string += f&#39;, capcost {currency(self.capcost(costs))}&#39;
        if self.opcost(costs) &gt; 0:
            string += f&#39;, opcost {currency(self.opcost(costs))}&#39;
        lcoe = self.lcoe(costs, context.years())
        if np.isfinite(lcoe) and lcoe &gt; 0:
            string += f&#39;, LCOE {currency(int(lcoe))}&#39;
        return string

    def set_capacity(self, cap):
        &#34;&#34;&#34;Change the capacity of the generator to cap GW.&#34;&#34;&#34;
        self.capacity = cap * 1000

    def __str__(self):
        &#34;&#34;&#34;Return a short string representation of the generator.&#34;&#34;&#34;
        return f&#39;{self.label} ({self.region()}:{self.polygon}), &#39; + \
            str(self.capacity * ureg.MW)

    def __repr__(self):
        &#34;&#34;&#34;Return a representation of the generator.&#34;&#34;&#34;
        return self.__str__()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="nemo.generators.Battery" href="#nemo.generators.Battery">Battery</a></li>
<li><a title="nemo.generators.BatteryLoad" href="#nemo.generators.BatteryLoad">BatteryLoad</a></li>
<li><a title="nemo.generators.Block" href="#nemo.generators.Block">Block</a></li>
<li><a title="nemo.generators.DemandResponse" href="#nemo.generators.DemandResponse">DemandResponse</a></li>
<li><a title="nemo.generators.Electrolyser" href="#nemo.generators.Electrolyser">Electrolyser</a></li>
<li><a title="nemo.generators.Fuelled" href="#nemo.generators.Fuelled">Fuelled</a></li>
<li><a title="nemo.generators.PumpedHydroPump" href="#nemo.generators.PumpedHydroPump">PumpedHydroPump</a></li>
<li><a title="nemo.generators.TraceGenerator" href="#nemo.generators.TraceGenerator">TraceGenerator</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nemo.generators.Generator.storage_p"><code class="name">var <span class="ident">storage_p</span></code></dt>
<dd>
<div class="desc"><p>A generator is not capable of storage by default.</p></div>
</dd>
<dt id="nemo.generators.Generator.synchronous_p"><code class="name">var <span class="ident">synchronous_p</span></code></dt>
<dd>
<div class="desc"><p>Is this a synchronous generator?</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nemo.generators.Generator.capcost"><code class="name flex">
<span>def <span class="ident">capcost</span></span>(<span>self, costs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the capital cost.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def capcost(self, costs):
    &#34;&#34;&#34;Return the capital cost.&#34;&#34;&#34;
    return costs.capcost_per_kw[type(self)] * self.capacity * 1000</code></pre>
</details>
</dd>
<dt id="nemo.generators.Generator.capfactor"><code class="name flex">
<span>def <span class="ident">capfactor</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Capacity factor of this generator (in %).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def capfactor(self):
    &#34;&#34;&#34;Capacity factor of this generator (in %).&#34;&#34;&#34;
    supplied = sum(self.series_power.values())
    hours = len(self.series_power)
    try:
        capfactor = supplied / (self.capacity * hours) * 100
        return capfactor
    except ZeroDivisionError:
        return float(&#39;nan&#39;)</code></pre>
</details>
</dd>
<dt id="nemo.generators.Generator.fixed_om_costs"><code class="name flex">
<span>def <span class="ident">fixed_om_costs</span></span>(<span>self, costs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the fixed O&amp;M costs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fixed_om_costs(self, costs):
    &#34;&#34;&#34;Return the fixed O&amp;M costs.&#34;&#34;&#34;
    return costs.fixed_om_costs[type(self)] * self.capacity * 1000</code></pre>
</details>
</dd>
<dt id="nemo.generators.Generator.lcoe"><code class="name flex">
<span>def <span class="ident">lcoe</span></span>(<span>self, costs, years)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the LCOE in $/MWh.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lcoe(self, costs, years):
    &#34;&#34;&#34;Calculate the LCOE in $/MWh.&#34;&#34;&#34;
    total_cost = self.capcost(costs) / costs.annuityf * years \
        + self.opcost(costs)
    supplied = sum(self.series_power.values())
    if supplied &gt; 0:
        cost_per_mwh = total_cost / supplied
        return cost_per_mwh
    return np.inf</code></pre>
</details>
</dd>
<dt id="nemo.generators.Generator.opcost"><code class="name flex">
<span>def <span class="ident">opcost</span></span>(<span>self, costs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the annual operating and maintenance cost.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def opcost(self, costs):
    &#34;&#34;&#34;Return the annual operating and maintenance cost.&#34;&#34;&#34;
    return self.fixed_om_costs(costs) + \
        sum(self.series_power.values()) * self.opcost_per_mwh(costs)</code></pre>
</details>
</dd>
<dt id="nemo.generators.Generator.opcost_per_mwh"><code class="name flex">
<span>def <span class="ident">opcost_per_mwh</span></span>(<span>self, costs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the variable O&amp;M costs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def opcost_per_mwh(self, costs):
    &#34;&#34;&#34;Return the variable O&amp;M costs.&#34;&#34;&#34;
    return costs.opcost_per_mwh[type(self)]</code></pre>
</details>
</dd>
<dt id="nemo.generators.Generator.region"><code class="name flex">
<span>def <span class="ident">region</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the region the generator is in.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def region(self):
    &#34;&#34;&#34;Return the region the generator is in.&#34;&#34;&#34;
    return polygons.region(self.polygon)</code></pre>
</details>
</dd>
<dt id="nemo.generators.Generator.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset the generator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    &#34;&#34;&#34;Reset the generator.&#34;&#34;&#34;
    self.series_power.clear()
    self.series_spilled.clear()</code></pre>
</details>
</dd>
<dt id="nemo.generators.Generator.series"><code class="name flex">
<span>def <span class="ident">series</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return generation and spills series.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def series(self):
    &#34;&#34;&#34;Return generation and spills series.&#34;&#34;&#34;
    return {&#39;power&#39;: pd.Series(self.series_power, dtype=float),
            &#39;spilled&#39;: pd.Series(self.series_spilled, dtype=float)}</code></pre>
</details>
</dd>
<dt id="nemo.generators.Generator.set_capacity"><code class="name flex">
<span>def <span class="ident">set_capacity</span></span>(<span>self, cap)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the capacity of the generator to cap GW.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_capacity(self, cap):
    &#34;&#34;&#34;Change the capacity of the generator to cap GW.&#34;&#34;&#34;
    self.capacity = cap * 1000</code></pre>
</details>
</dd>
<dt id="nemo.generators.Generator.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, hour, demand)</span>
</code></dt>
<dd>
<div class="desc"><p>Step the generator by one hour.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, hour, demand):
    &#34;&#34;&#34;Step the generator by one hour.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="nemo.generators.Generator.summary"><code class="name flex">
<span>def <span class="ident">summary</span></span>(<span>self, context)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a summary of the generator activity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def summary(self, context):
    &#34;&#34;&#34;Return a summary of the generator activity.&#34;&#34;&#34;
    costs = context.costs
    supplied = sum(self.series_power.values()) * ureg.MWh
    string = f&#39;supplied {supplied.to_compact()}&#39;
    if self.capacity &gt; 0:
        if self.capfactor() &gt; 0:
            string += f&#39;, CF {self.capfactor():.1f}%&#39;
    if sum(self.series_spilled.values()) &gt; 0:
        spilled = sum(self.series_spilled.values()) * ureg.MWh
        string += f&#39;, surplus {spilled.to_compact()}&#39;
    if self.capcost(costs) &gt; 0:
        string += f&#39;, capcost {currency(self.capcost(costs))}&#39;
    if self.opcost(costs) &gt; 0:
        string += f&#39;, opcost {currency(self.opcost(costs))}&#39;
    lcoe = self.lcoe(costs, context.years())
    if np.isfinite(lcoe) and lcoe &gt; 0:
        string += f&#39;, LCOE {currency(int(lcoe))}&#39;
    return string</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="nemo.generators.Geothermal"><code class="flex name class">
<span>class <span class="ident">Geothermal</span></span>
<span>(</span><span>polygon, capacity, filename, column, label=None, build_limit=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Geothermal power plant.</p>
<p>Construct a generator with a specified trace file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Geothermal(CSVTraceGenerator):
    &#34;&#34;&#34;Geothermal power plant.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;indianred&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def step(self, hour, demand):
        &#34;&#34;&#34;Specialised step method for geothermal generators.

        Geothermal power plants do not spill.
        &#34;&#34;&#34;
        generation = self.generation[hour] * self.capacity
        power = min(generation, demand)
        self.series_power[hour] = power
        self.series_spilled[hour] = 0
        return power, 0</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.CSVTraceGenerator" href="#nemo.generators.CSVTraceGenerator">CSVTraceGenerator</a></li>
<li><a title="nemo.generators.TraceGenerator" href="#nemo.generators.TraceGenerator">TraceGenerator</a></li>
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="nemo.generators.Geothermal_EGS" href="#nemo.generators.Geothermal_EGS">Geothermal_EGS</a></li>
<li><a title="nemo.generators.Geothermal_HSA" href="#nemo.generators.Geothermal_HSA">Geothermal_HSA</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nemo.generators.Geothermal.patch"><code class="name">var <span class="ident">patch</span></code></dt>
<dd>
<div class="desc"><p>Colour for plotting</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nemo.generators.Geothermal.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, hour, demand)</span>
</code></dt>
<dd>
<div class="desc"><p>Specialised step method for geothermal generators.</p>
<p>Geothermal power plants do not spill.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, hour, demand):
    &#34;&#34;&#34;Specialised step method for geothermal generators.

    Geothermal power plants do not spill.
    &#34;&#34;&#34;
    generation = self.generation[hour] * self.capacity
    power = min(generation, demand)
    self.series_power[hour] = power
    self.series_spilled[hour] = 0
    return power, 0</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.CSVTraceGenerator" href="#nemo.generators.CSVTraceGenerator">CSVTraceGenerator</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.CSVTraceGenerator.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.Geothermal_EGS"><code class="flex name class">
<span>class <span class="ident">Geothermal_EGS</span></span>
<span>(</span><span>polygon, capacity, filename, column, label=None, build_limit=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Enhanced geothermal systems (EGS) geothermal model.</p>
<p>Construct a generator with a specified trace file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Geothermal_EGS(Geothermal):
    &#34;&#34;&#34;Enhanced geothermal systems (EGS) geothermal model.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.Geothermal" href="#nemo.generators.Geothermal">Geothermal</a></li>
<li><a title="nemo.generators.CSVTraceGenerator" href="#nemo.generators.CSVTraceGenerator">CSVTraceGenerator</a></li>
<li><a title="nemo.generators.TraceGenerator" href="#nemo.generators.TraceGenerator">TraceGenerator</a></li>
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.Geothermal" href="#nemo.generators.Geothermal">Geothermal</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.Geothermal.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.Geothermal.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.Geothermal.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.Geothermal.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.Geothermal.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.Geothermal.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.Geothermal.patch" href="#nemo.generators.Geothermal.patch">patch</a></code></li>
<li><code><a title="nemo.generators.Geothermal.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.Geothermal.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.Geothermal.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.Geothermal.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.Geothermal.step" href="#nemo.generators.Geothermal.step">step</a></code></li>
<li><code><a title="nemo.generators.Geothermal.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.Geothermal.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.Geothermal.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.Geothermal_HSA"><code class="flex name class">
<span>class <span class="ident">Geothermal_HSA</span></span>
<span>(</span><span>polygon, capacity, filename, column, label=None, build_limit=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Hot sedimentary aquifer (HSA) geothermal model.</p>
<p>Construct a generator with a specified trace file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Geothermal_HSA(Geothermal):
    &#34;&#34;&#34;Hot sedimentary aquifer (HSA) geothermal model.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.Geothermal" href="#nemo.generators.Geothermal">Geothermal</a></li>
<li><a title="nemo.generators.CSVTraceGenerator" href="#nemo.generators.CSVTraceGenerator">CSVTraceGenerator</a></li>
<li><a title="nemo.generators.TraceGenerator" href="#nemo.generators.TraceGenerator">TraceGenerator</a></li>
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.Geothermal" href="#nemo.generators.Geothermal">Geothermal</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.Geothermal.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.Geothermal.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.Geothermal.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.Geothermal.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.Geothermal.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.Geothermal.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.Geothermal.patch" href="#nemo.generators.Geothermal.patch">patch</a></code></li>
<li><code><a title="nemo.generators.Geothermal.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.Geothermal.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.Geothermal.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.Geothermal.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.Geothermal.step" href="#nemo.generators.Geothermal.step">step</a></code></li>
<li><code><a title="nemo.generators.Geothermal.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.Geothermal.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.Geothermal.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.Hydro"><code class="flex name class">
<span>class <span class="ident">Hydro</span></span>
<span>(</span><span>polygon, capacity, label=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Hydro power stations.</p>
<p>Construct a hydroelectric generator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Hydro(Fuelled):
    &#34;&#34;&#34;Hydro power stations.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;#4582b4&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, polygon, capacity, label=None):
        &#34;&#34;&#34;Construct a hydroelectric generator.&#34;&#34;&#34;
        Fuelled.__init__(self, polygon, capacity, label)
        # capacity is in MW, but build limit is in GW
        self.setters = [(self.set_capacity, 0, capacity / 1000.)]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.Fuelled" href="#nemo.generators.Fuelled">Fuelled</a></li>
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="nemo.generators.PumpedHydroTurbine" href="#nemo.generators.PumpedHydroTurbine">PumpedHydroTurbine</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nemo.generators.Hydro.patch"><code class="name">var <span class="ident">patch</span></code></dt>
<dd>
<div class="desc"><p>Colour for plotting</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.Fuelled" href="#nemo.generators.Fuelled">Fuelled</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.Fuelled.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.Fuelled.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.Fuelled.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.Fuelled.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.Fuelled.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.Fuelled.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.Fuelled.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.Fuelled.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.Fuelled.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.Fuelled.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.Fuelled.step" href="#nemo.generators.Fuelled.step">step</a></code></li>
<li><code><a title="nemo.generators.Fuelled.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.Fuelled.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.Fuelled.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.HydrogenGT"><code class="flex name class">
<span>class <span class="ident">HydrogenGT</span></span>
<span>(</span><span>tank, polygon, capacity, efficiency=0.36, label=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A combustion turbine fuelled by hydrogen.</p>
<p>Construct a HydrogenGT object.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; h = storage.HydrogenStorage(1000, 'test')
&gt;&gt;&gt; gt = HydrogenGT(h, 1, 100, efficiency=0.5)
&gt;&gt;&gt; print(gt)
HydrogenGT (QLD1:1), 100.00 MW
&gt;&gt;&gt; gt.step(0, 100) # discharge 100 MWh-e of hydrogen
(100.0, 0)
&gt;&gt;&gt; gt.step(0, 100) # discharge another 100 MWh-e of hydrogen
(100.0, 0)
&gt;&gt;&gt; h.storage == (1000 / 2.) - (200 / gt.efficiency)
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HydrogenGT(Fuelled):
    &#34;&#34;&#34;A combustion turbine fuelled by hydrogen.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;violet&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, tank, polygon, capacity, efficiency=0.36, label=None):
        &#34;&#34;&#34;
        Construct a HydrogenGT object.

        &gt;&gt;&gt; h = storage.HydrogenStorage(1000, &#39;test&#39;)
        &gt;&gt;&gt; gt = HydrogenGT(h, 1, 100, efficiency=0.5)
        &gt;&gt;&gt; print(gt)
        HydrogenGT (QLD1:1), 100.00 MW
        &gt;&gt;&gt; gt.step(0, 100) # discharge 100 MWh-e of hydrogen
        (100.0, 0)
        &gt;&gt;&gt; gt.step(0, 100) # discharge another 100 MWh-e of hydrogen
        (100.0, 0)
        &gt;&gt;&gt; h.storage == (1000 / 2.) - (200 / gt.efficiency)
        True
        &#34;&#34;&#34;
        assert isinstance(tank, storage.HydrogenStorage)
        Fuelled.__init__(self, polygon, capacity, label)
        self.tank = tank
        self.efficiency = efficiency

    def step(self, hour, demand):
        &#34;&#34;&#34;Step method for hydrogen comubstion turbine generators.&#34;&#34;&#34;
        # calculate hydrogen requirement
        hydrogen = min(self.capacity, demand) / self.efficiency
        # discharge that amount of hydrogen
        power = self.tank.discharge(hydrogen) * self.efficiency
        self.series_power[hour] = power
        self.series_spilled[hour] = 0
        if power &gt; 0:
            self.runhours += 1
        return power, 0

    def capcost(self, costs):
        &#34;&#34;&#34;Return the capital cost (of an OCGT).&#34;&#34;&#34;
        return costs.capcost_per_kw[OCGT] * self.capacity * 1000

    def fixed_om_costs(self, costs):
        &#34;&#34;&#34;Return the fixed O&amp;M costs (of an OCGT).&#34;&#34;&#34;
        return costs.fixed_om_costs[OCGT] * self.capacity * 1000

    def opcost_per_mwh(self, costs):
        &#34;&#34;&#34;Return the variable O&amp;M costs (of an OCGT).&#34;&#34;&#34;
        return costs.opcost_per_mwh[OCGT]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.Fuelled" href="#nemo.generators.Fuelled">Fuelled</a></li>
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nemo.generators.HydrogenGT.patch"><code class="name">var <span class="ident">patch</span></code></dt>
<dd>
<div class="desc"><p>Colour for plotting</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nemo.generators.HydrogenGT.capcost"><code class="name flex">
<span>def <span class="ident">capcost</span></span>(<span>self, costs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the capital cost (of an OCGT).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def capcost(self, costs):
    &#34;&#34;&#34;Return the capital cost (of an OCGT).&#34;&#34;&#34;
    return costs.capcost_per_kw[OCGT] * self.capacity * 1000</code></pre>
</details>
</dd>
<dt id="nemo.generators.HydrogenGT.fixed_om_costs"><code class="name flex">
<span>def <span class="ident">fixed_om_costs</span></span>(<span>self, costs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the fixed O&amp;M costs (of an OCGT).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fixed_om_costs(self, costs):
    &#34;&#34;&#34;Return the fixed O&amp;M costs (of an OCGT).&#34;&#34;&#34;
    return costs.fixed_om_costs[OCGT] * self.capacity * 1000</code></pre>
</details>
</dd>
<dt id="nemo.generators.HydrogenGT.opcost_per_mwh"><code class="name flex">
<span>def <span class="ident">opcost_per_mwh</span></span>(<span>self, costs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the variable O&amp;M costs (of an OCGT).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def opcost_per_mwh(self, costs):
    &#34;&#34;&#34;Return the variable O&amp;M costs (of an OCGT).&#34;&#34;&#34;
    return costs.opcost_per_mwh[OCGT]</code></pre>
</details>
</dd>
<dt id="nemo.generators.HydrogenGT.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, hour, demand)</span>
</code></dt>
<dd>
<div class="desc"><p>Step method for hydrogen comubstion turbine generators.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, hour, demand):
    &#34;&#34;&#34;Step method for hydrogen comubstion turbine generators.&#34;&#34;&#34;
    # calculate hydrogen requirement
    hydrogen = min(self.capacity, demand) / self.efficiency
    # discharge that amount of hydrogen
    power = self.tank.discharge(hydrogen) * self.efficiency
    self.series_power[hour] = power
    self.series_spilled[hour] = 0
    if power &gt; 0:
        self.runhours += 1
    return power, 0</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.Fuelled" href="#nemo.generators.Fuelled">Fuelled</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.Fuelled.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.Fuelled.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.Fuelled.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.Fuelled.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.Fuelled.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.Fuelled.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.Fuelled.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.Fuelled.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.Fuelled.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.Fuelled.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.OCGT"><code class="flex name class">
<span>class <span class="ident">OCGT</span></span>
<span>(</span><span>polygon, capacity, intensity=0.7, label=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Open cycle gas turbine (OCGT) model.</p>
<p>Construct an OCGT generator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OCGT(Fossil):
    &#34;&#34;&#34;Open cycle gas turbine (OCGT) model.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;#ffcd96&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, polygon, capacity, intensity=0.7, label=None):
        &#34;&#34;&#34;Construct an OCGT generator.&#34;&#34;&#34;
        Fossil.__init__(self, polygon, capacity, intensity, label)

    def opcost_per_mwh(self, costs):
        &#34;&#34;&#34;Return the variable O&amp;M costs.&#34;&#34;&#34;
        vom = costs.opcost_per_mwh[type(self)]
        fuel_cost = costs.gas_price_per_gj * 11.61
        total_opcost = vom + fuel_cost + self.intensity * costs.carbon
        return total_opcost</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.Fossil" href="#nemo.generators.Fossil">Fossil</a></li>
<li><a title="nemo.generators.Fuelled" href="#nemo.generators.Fuelled">Fuelled</a></li>
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.Fossil" href="#nemo.generators.Fossil">Fossil</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.Fossil.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.Fossil.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.Fossil.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.Fossil.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.Fossil.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.Fossil.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.Fossil.patch" href="#nemo.generators.Fossil.patch">patch</a></code></li>
<li><code><a title="nemo.generators.Fossil.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.Fossil.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.Fossil.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.Fossil.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.Fossil.step" href="#nemo.generators.Fuelled.step">step</a></code></li>
<li><code><a title="nemo.generators.Fossil.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.Fossil.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.Fossil.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.PV"><code class="flex name class">
<span>class <span class="ident">PV</span></span>
<span>(</span><span>polygon, capacity, filename, column, label=None, build_limit=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Solar photovoltaic (PV) model.</p>
<p>Construct a generator with a specified trace file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PV(CSVTraceGenerator):
    &#34;&#34;&#34;Solar photovoltaic (PV) model.&#34;&#34;&#34;

    synchronous_p = False
    &#34;&#34;&#34;Is this a synchronous generator?&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.CSVTraceGenerator" href="#nemo.generators.CSVTraceGenerator">CSVTraceGenerator</a></li>
<li><a title="nemo.generators.TraceGenerator" href="#nemo.generators.TraceGenerator">TraceGenerator</a></li>
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="nemo.generators.Behind_Meter_PV" href="#nemo.generators.Behind_Meter_PV">Behind_Meter_PV</a></li>
<li><a title="nemo.generators.PV1Axis" href="#nemo.generators.PV1Axis">PV1Axis</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.CSVTraceGenerator" href="#nemo.generators.CSVTraceGenerator">CSVTraceGenerator</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.CSVTraceGenerator.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.step" href="#nemo.generators.TraceGenerator.step">step</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.PV1Axis"><code class="flex name class">
<span>class <span class="ident">PV1Axis</span></span>
<span>(</span><span>polygon, capacity, filename, column, label=None, build_limit=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Single-axis tracking PV.</p>
<p>Construct a generator with a specified trace file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PV1Axis(PV):
    &#34;&#34;&#34;Single-axis tracking PV.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;#fed500&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.PV" href="#nemo.generators.PV">PV</a></li>
<li><a title="nemo.generators.CSVTraceGenerator" href="#nemo.generators.CSVTraceGenerator">CSVTraceGenerator</a></li>
<li><a title="nemo.generators.TraceGenerator" href="#nemo.generators.TraceGenerator">TraceGenerator</a></li>
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nemo.generators.PV1Axis.patch"><code class="name">var <span class="ident">patch</span></code></dt>
<dd>
<div class="desc"><p>Colour for plotting</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.PV" href="#nemo.generators.PV">PV</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.PV.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.PV.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.PV.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.PV.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.PV.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.PV.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.PV.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.PV.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.PV.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.PV.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.PV.step" href="#nemo.generators.TraceGenerator.step">step</a></code></li>
<li><code><a title="nemo.generators.PV.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.PV.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.PV.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.ParabolicTrough"><code class="flex name class">
<span>class <span class="ident">ParabolicTrough</span></span>
<span>(</span><span>polygon, capacity, solarmult, shours, filename, column, label=None, build_limit=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Parabolic trough CST generator.</p>
<p>This stub class allows differentiated CST costs in costs.py.</p>
<p>Construct a CST generator.</p>
<p>Arguments include capacity (in MW), sm (solar multiple) and
shours (hours of storage).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParabolicTrough(CST):
    &#34;&#34;&#34;Parabolic trough CST generator.

    This stub class allows differentiated CST costs in costs.py.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.CST" href="#nemo.generators.CST">CST</a></li>
<li><a title="nemo.generators.CSVTraceGenerator" href="#nemo.generators.CSVTraceGenerator">CSVTraceGenerator</a></li>
<li><a title="nemo.generators.TraceGenerator" href="#nemo.generators.TraceGenerator">TraceGenerator</a></li>
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.CST" href="#nemo.generators.CST">CST</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.CST.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.CST.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.CST.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.CST.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.CST.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.CST.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.CST.patch" href="#nemo.generators.CST.patch">patch</a></code></li>
<li><code><a title="nemo.generators.CST.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.CST.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.CST.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.CST.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.CST.set_multiple" href="#nemo.generators.CST.set_multiple">set_multiple</a></code></li>
<li><code><a title="nemo.generators.CST.set_storage" href="#nemo.generators.CST.set_storage">set_storage</a></code></li>
<li><code><a title="nemo.generators.CST.step" href="#nemo.generators.CST.step">step</a></code></li>
<li><code><a title="nemo.generators.CST.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.CST.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.CST.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.PumpedHydroPump"><code class="flex name class">
<span>class <span class="ident">PumpedHydroPump</span></span>
<span>(</span><span>polygon, capacity, reservoirs, rte=0.8, label=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Pumped hydro (pump side) model.</p>
<p>Construct a pumped hydro storage generator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PumpedHydroPump(Storage, Generator):
    &#34;&#34;&#34;Pumped hydro (pump side) model.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;darkblue&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, polygon, capacity, reservoirs, rte=0.8, label=None):
        &#34;&#34;&#34;Construct a pumped hydro storage generator.&#34;&#34;&#34;
        if not isinstance(reservoirs, storage.PumpedHydroStorage):
            raise TypeError
        Storage.__init__(self)
        Generator.__init__(self, polygon, capacity, label)
        self.reservoirs = reservoirs
        self.rte = rte

    def step(self, hour, demand):
        &#34;&#34;&#34;Return 0 as this is not a generator.&#34;&#34;&#34;
        return 0, 0

    def series(self):
        &#34;&#34;&#34;Return the combined series.&#34;&#34;&#34;
        dict1 = Hydro.series(self)
        dict2 = Storage.series(self)
        dict1.update(dict2)
        return dict1

    def soc(self):
        &#34;&#34;&#34;Return the pumped hydro SOC (state of charge).&#34;&#34;&#34;
        return self.reservoirs.soc()

    def store(self, hour, power):
        &#34;&#34;&#34;Pump water uphill for one hour.&#34;&#34;&#34;
        if self.reservoirs.last_gen == hour:
            # Can&#39;t pump and generate in the same hour.
            return 0
        power = min(self.charge_capacity(self, hour), power,
                    self.capacity)

        stored = self.reservoirs.charge(power * self.rte)
        if stored &lt; power * self.rte:
            power = (self.reservoirs.maxstorage - self.reservoirs.storage) \
                / self.rte

        if power &gt; 0:
            self.record(hour, power)
            self.reservoirs.last_pump = hour
        return power

    def reset(self):
        &#34;&#34;&#34;Reset the generator.&#34;&#34;&#34;
        Generator.reset(self)
        Storage.reset(self)
        self.reservoirs.reset()

    def summary(self, context):
        &#34;&#34;&#34;Return a summary of the generator activity.&#34;&#34;&#34;
        stg = (self.reservoirs.maxstorage * ureg.MWh).to_compact()
        return Generator.summary(self, context) + \
            f&#39;, charged {thousands(len(self.series_charge))} hours&#39; + \
            f&#39;, {stg} storage&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.Storage" href="#nemo.generators.Storage">Storage</a></li>
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nemo.generators.PumpedHydroPump.patch"><code class="name">var <span class="ident">patch</span></code></dt>
<dd>
<div class="desc"><p>Colour for plotting</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nemo.generators.PumpedHydroPump.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset the generator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    &#34;&#34;&#34;Reset the generator.&#34;&#34;&#34;
    Generator.reset(self)
    Storage.reset(self)
    self.reservoirs.reset()</code></pre>
</details>
</dd>
<dt id="nemo.generators.PumpedHydroPump.series"><code class="name flex">
<span>def <span class="ident">series</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the combined series.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def series(self):
    &#34;&#34;&#34;Return the combined series.&#34;&#34;&#34;
    dict1 = Hydro.series(self)
    dict2 = Storage.series(self)
    dict1.update(dict2)
    return dict1</code></pre>
</details>
</dd>
<dt id="nemo.generators.PumpedHydroPump.soc"><code class="name flex">
<span>def <span class="ident">soc</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the pumped hydro SOC (state of charge).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def soc(self):
    &#34;&#34;&#34;Return the pumped hydro SOC (state of charge).&#34;&#34;&#34;
    return self.reservoirs.soc()</code></pre>
</details>
</dd>
<dt id="nemo.generators.PumpedHydroPump.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, hour, demand)</span>
</code></dt>
<dd>
<div class="desc"><p>Return 0 as this is not a generator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, hour, demand):
    &#34;&#34;&#34;Return 0 as this is not a generator.&#34;&#34;&#34;
    return 0, 0</code></pre>
</details>
</dd>
<dt id="nemo.generators.PumpedHydroPump.store"><code class="name flex">
<span>def <span class="ident">store</span></span>(<span>self, hour, power)</span>
</code></dt>
<dd>
<div class="desc"><p>Pump water uphill for one hour.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def store(self, hour, power):
    &#34;&#34;&#34;Pump water uphill for one hour.&#34;&#34;&#34;
    if self.reservoirs.last_gen == hour:
        # Can&#39;t pump and generate in the same hour.
        return 0
    power = min(self.charge_capacity(self, hour), power,
                self.capacity)

    stored = self.reservoirs.charge(power * self.rte)
    if stored &lt; power * self.rte:
        power = (self.reservoirs.maxstorage - self.reservoirs.storage) \
            / self.rte

    if power &gt; 0:
        self.record(hour, power)
        self.reservoirs.last_pump = hour
    return power</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.Storage" href="#nemo.generators.Storage">Storage</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.Storage.charge_capacity" href="#nemo.generators.Storage.charge_capacity">charge_capacity</a></code></li>
<li><code><a title="nemo.generators.Storage.record" href="#nemo.generators.Storage.record">record</a></code></li>
<li><code><a title="nemo.generators.Storage.storage_p" href="#nemo.generators.Storage.storage_p">storage_p</a></code></li>
</ul>
</li>
<li><code><b><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.Generator.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
</ul>
</li>
<li><code><b><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.Generator.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.Generator.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.Generator.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.Generator.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.Generator.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.Generator.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.Generator.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.Generator.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.Generator.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.PumpedHydroTurbine"><code class="flex name class">
<span>class <span class="ident">PumpedHydroTurbine</span></span>
<span>(</span><span>polygon, capacity, reservoirs, label=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Pumped storage hydro (generator side) model.</p>
<p>Construct a pumped hydro storage generator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PumpedHydroTurbine(Hydro):
    &#34;&#34;&#34;Pumped storage hydro (generator side) model.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;powderblue&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;

    def __init__(self, polygon, capacity, reservoirs, label=None):
        &#34;&#34;&#34;Construct a pumped hydro storage generator.&#34;&#34;&#34;
        if not isinstance(reservoirs, storage.PumpedHydroStorage):
            raise TypeError
        Hydro.__init__(self, polygon, capacity, label)
        self.reservoirs = reservoirs

    def step(self, hour, demand):
        &#34;&#34;&#34;Step method for pumped hydro storage.&#34;&#34;&#34;
        power = min(self.reservoirs.storage, self.capacity, demand)
        if self.reservoirs.last_pump == hour:
            # Can&#39;t pump and generate in the same hour.
            self.series_power[hour] = 0
            self.series_spilled[hour] = 0
            return 0, 0

        self.reservoirs.discharge(power)
        self.series_power[hour] = power
        self.series_spilled[hour] = 0
        if power &gt; 0:
            self.runhours += 1
            self.reservoirs.last_gen = hour
        return power, 0</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.Hydro" href="#nemo.generators.Hydro">Hydro</a></li>
<li><a title="nemo.generators.Fuelled" href="#nemo.generators.Fuelled">Fuelled</a></li>
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="nemo.generators.PumpedHydroTurbine.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, hour, demand)</span>
</code></dt>
<dd>
<div class="desc"><p>Step method for pumped hydro storage.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, hour, demand):
    &#34;&#34;&#34;Step method for pumped hydro storage.&#34;&#34;&#34;
    power = min(self.reservoirs.storage, self.capacity, demand)
    if self.reservoirs.last_pump == hour:
        # Can&#39;t pump and generate in the same hour.
        self.series_power[hour] = 0
        self.series_spilled[hour] = 0
        return 0, 0

    self.reservoirs.discharge(power)
    self.series_power[hour] = power
    self.series_spilled[hour] = 0
    if power &gt; 0:
        self.runhours += 1
        self.reservoirs.last_gen = hour
    return power, 0</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.Hydro" href="#nemo.generators.Hydro">Hydro</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.Hydro.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.Hydro.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.Hydro.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.Hydro.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.Hydro.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.Hydro.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.Hydro.patch" href="#nemo.generators.Hydro.patch">patch</a></code></li>
<li><code><a title="nemo.generators.Hydro.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.Hydro.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.Hydro.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.Hydro.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.Hydro.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.Hydro.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.Hydro.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.Storage"><code class="flex name class">
<span>class <span class="ident">Storage</span></span>
</code></dt>
<dd>
<div class="desc"><p>A class to give a generator storage capability.</p>
<p>Storage constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Storage():
    &#34;&#34;&#34;A class to give a generator storage capability.&#34;&#34;&#34;

    storage_p = True
    &#34;&#34;&#34;This generator is capable of storage.&#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Storage constructor.&#34;&#34;&#34;
        # Time series of charges
        self.series_charge = {}
        self.series_soc = {}

    def soc(self):
        &#34;&#34;&#34;Return the storage SOC (state of charge).&#34;&#34;&#34;
        raise NotImplementedError

    def record(self, hour, energy):
        &#34;&#34;&#34;Record storage.&#34;&#34;&#34;
        if hour not in self.series_charge:
            self.series_charge[hour] = 0
        self.series_charge[hour] += energy
        self.series_soc[hour] = self.soc()

    def charge_capacity(self, gen, hour):
        &#34;&#34;&#34;Return available storage capacity.

        Since a storage-capable generator can be called on multiple
        times to store energy in a single timestep, we keep track of
        how much remaining capacity is available for charging in the
        given timestep.
        &#34;&#34;&#34;
        try:
            result = gen.capacity - self.series_charge[hour]
            if result &lt; 0 or isclose(result, 0, abs_tol=1e-6):
                result = 0
            assert result &gt;= 0
            return result
        except KeyError:
            return gen.capacity

    def series(self):
        &#34;&#34;&#34;Return generation and spills series.&#34;&#34;&#34;
        return {&#39;charge&#39;: pd.Series(self.series_charge, dtype=float),
                &#39;soc&#39;: pd.Series(self.series_soc, dtype=float)}

    def store(self, hour, power):
        &#34;&#34;&#34;Abstract method to ensure that derived classes define this.&#34;&#34;&#34;
        raise NotImplementedError

    def reset(self):
        &#34;&#34;&#34;Reset a generator with storage.&#34;&#34;&#34;
        self.series_charge.clear()
        self.series_soc.clear()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="nemo.generators.BatteryLoad" href="#nemo.generators.BatteryLoad">BatteryLoad</a></li>
<li><a title="nemo.generators.Electrolyser" href="#nemo.generators.Electrolyser">Electrolyser</a></li>
<li><a title="nemo.generators.PumpedHydroPump" href="#nemo.generators.PumpedHydroPump">PumpedHydroPump</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nemo.generators.Storage.storage_p"><code class="name">var <span class="ident">storage_p</span></code></dt>
<dd>
<div class="desc"><p>This generator is capable of storage.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nemo.generators.Storage.charge_capacity"><code class="name flex">
<span>def <span class="ident">charge_capacity</span></span>(<span>self, gen, hour)</span>
</code></dt>
<dd>
<div class="desc"><p>Return available storage capacity.</p>
<p>Since a storage-capable generator can be called on multiple
times to store energy in a single timestep, we keep track of
how much remaining capacity is available for charging in the
given timestep.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def charge_capacity(self, gen, hour):
    &#34;&#34;&#34;Return available storage capacity.

    Since a storage-capable generator can be called on multiple
    times to store energy in a single timestep, we keep track of
    how much remaining capacity is available for charging in the
    given timestep.
    &#34;&#34;&#34;
    try:
        result = gen.capacity - self.series_charge[hour]
        if result &lt; 0 or isclose(result, 0, abs_tol=1e-6):
            result = 0
        assert result &gt;= 0
        return result
    except KeyError:
        return gen.capacity</code></pre>
</details>
</dd>
<dt id="nemo.generators.Storage.record"><code class="name flex">
<span>def <span class="ident">record</span></span>(<span>self, hour, energy)</span>
</code></dt>
<dd>
<div class="desc"><p>Record storage.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def record(self, hour, energy):
    &#34;&#34;&#34;Record storage.&#34;&#34;&#34;
    if hour not in self.series_charge:
        self.series_charge[hour] = 0
    self.series_charge[hour] += energy
    self.series_soc[hour] = self.soc()</code></pre>
</details>
</dd>
<dt id="nemo.generators.Storage.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset a generator with storage.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    &#34;&#34;&#34;Reset a generator with storage.&#34;&#34;&#34;
    self.series_charge.clear()
    self.series_soc.clear()</code></pre>
</details>
</dd>
<dt id="nemo.generators.Storage.series"><code class="name flex">
<span>def <span class="ident">series</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return generation and spills series.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def series(self):
    &#34;&#34;&#34;Return generation and spills series.&#34;&#34;&#34;
    return {&#39;charge&#39;: pd.Series(self.series_charge, dtype=float),
            &#39;soc&#39;: pd.Series(self.series_soc, dtype=float)}</code></pre>
</details>
</dd>
<dt id="nemo.generators.Storage.soc"><code class="name flex">
<span>def <span class="ident">soc</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the storage SOC (state of charge).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def soc(self):
    &#34;&#34;&#34;Return the storage SOC (state of charge).&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="nemo.generators.Storage.store"><code class="name flex">
<span>def <span class="ident">store</span></span>(<span>self, hour, power)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract method to ensure that derived classes define this.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def store(self, hour, power):
    &#34;&#34;&#34;Abstract method to ensure that derived classes define this.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="nemo.generators.TraceGenerator"><code class="flex name class">
<span>class <span class="ident">TraceGenerator</span></span>
<span>(</span><span>polygon, capacity, label=None, build_limit=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A generator that gets its hourly dispatch from a CSV trace file.</p>
<p>Construct a generator with a specified trace file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TraceGenerator(Generator):
    &#34;&#34;&#34;A generator that gets its hourly dispatch from a CSV trace file.&#34;&#34;&#34;

    csvfilename = None
    csvdata = None

    def __init__(self, polygon, capacity, label=None, build_limit=None):
        &#34;&#34;&#34;Construct a generator with a specified trace file.&#34;&#34;&#34;
        Generator.__init__(self, polygon, capacity, label)
        if build_limit is not None:
            # Override default capacity limit with build_limit
            _, _, limit = self.setters[0]
            self.setters = [(self.set_capacity, 0, min(build_limit, limit))]

    def step(self, hour, demand):
        &#34;&#34;&#34;Step method for any generator using traces.&#34;&#34;&#34;
        # self.generation must be defined by derived classes
        # pylint: disable=no-member
        generation = self.generation[hour] * self.capacity
        # optimised version of min() because TraceGenerator is a
        # heavily used class
        power = generation if generation &lt; demand else demand
        spilled = generation - power
        self.series_power[hour] = power
        self.series_spilled[hour] = spilled
        return power, spilled</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="nemo.generators.CSVTraceGenerator" href="#nemo.generators.CSVTraceGenerator">CSVTraceGenerator</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nemo.generators.TraceGenerator.csvdata"><code class="name">var <span class="ident">csvdata</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nemo.generators.TraceGenerator.csvfilename"><code class="name">var <span class="ident">csvfilename</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nemo.generators.TraceGenerator.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, hour, demand)</span>
</code></dt>
<dd>
<div class="desc"><p>Step method for any generator using traces.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, hour, demand):
    &#34;&#34;&#34;Step method for any generator using traces.&#34;&#34;&#34;
    # self.generation must be defined by derived classes
    # pylint: disable=no-member
    generation = self.generation[hour] * self.capacity
    # optimised version of min() because TraceGenerator is a
    # heavily used class
    power = generation if generation &lt; demand else demand
    spilled = generation - power
    self.series_power[hour] = power
    self.series_spilled[hour] = spilled
    return power, spilled</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.Generator.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.Generator.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.Generator.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.Generator.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.Generator.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.Generator.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.Generator.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.Generator.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.Generator.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.Generator.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.Generator.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.Generator.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.Generator.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.Wind"><code class="flex name class">
<span>class <span class="ident">Wind</span></span>
<span>(</span><span>polygon, capacity, filename, column, label=None, build_limit=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Wind power.</p>
<p>Construct a generator with a specified trace file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Wind(CSVTraceGenerator):
    &#34;&#34;&#34;Wind power.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;#417505&#39;)
    &#34;&#34;&#34;Patch for plotting&#34;&#34;&#34;
    synchronous_p = False
    &#34;&#34;&#34;Is this a synchronous generator?&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.CSVTraceGenerator" href="#nemo.generators.CSVTraceGenerator">CSVTraceGenerator</a></li>
<li><a title="nemo.generators.TraceGenerator" href="#nemo.generators.TraceGenerator">TraceGenerator</a></li>
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="nemo.generators.WindOffshore" href="#nemo.generators.WindOffshore">WindOffshore</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nemo.generators.Wind.patch"><code class="name">var <span class="ident">patch</span></code></dt>
<dd>
<div class="desc"><p>Patch for plotting</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.CSVTraceGenerator" href="#nemo.generators.CSVTraceGenerator">CSVTraceGenerator</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.CSVTraceGenerator.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.step" href="#nemo.generators.TraceGenerator.step">step</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nemo.generators.WindOffshore"><code class="flex name class">
<span>class <span class="ident">WindOffshore</span></span>
<span>(</span><span>polygon, capacity, filename, column, label=None, build_limit=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Offshore wind power.</p>
<p>Construct a generator with a specified trace file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WindOffshore(Wind):
    &#34;&#34;&#34;Offshore wind power.&#34;&#34;&#34;

    patch = Patch(facecolor=&#39;darkgreen&#39;)
    &#34;&#34;&#34;Colour for plotting&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nemo.generators.Wind" href="#nemo.generators.Wind">Wind</a></li>
<li><a title="nemo.generators.CSVTraceGenerator" href="#nemo.generators.CSVTraceGenerator">CSVTraceGenerator</a></li>
<li><a title="nemo.generators.TraceGenerator" href="#nemo.generators.TraceGenerator">TraceGenerator</a></li>
<li><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nemo.generators.Wind" href="#nemo.generators.Wind">Wind</a></b></code>:
<ul class="hlist">
<li><code><a title="nemo.generators.Wind.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.Wind.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.Wind.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.Wind.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.Wind.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.Wind.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.Wind.patch" href="#nemo.generators.Wind.patch">patch</a></code></li>
<li><code><a title="nemo.generators.Wind.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.Wind.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.Wind.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.Wind.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.Wind.step" href="#nemo.generators.TraceGenerator.step">step</a></code></li>
<li><code><a title="nemo.generators.Wind.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.Wind.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.Wind.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nemo" href="index.html">nemo</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="nemo.generators.Battery" href="#nemo.generators.Battery">Battery</a></code></h4>
<ul class="">
<li><code><a title="nemo.generators.Battery.opcost_per_mwh" href="#nemo.generators.Battery.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.Battery.patch" href="#nemo.generators.Battery.patch">patch</a></code></li>
<li><code><a title="nemo.generators.Battery.soc" href="#nemo.generators.Battery.soc">soc</a></code></li>
<li><code><a title="nemo.generators.Battery.step" href="#nemo.generators.Battery.step">step</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nemo.generators.BatteryLoad" href="#nemo.generators.BatteryLoad">BatteryLoad</a></code></h4>
<ul class="two-column">
<li><code><a title="nemo.generators.BatteryLoad.patch" href="#nemo.generators.BatteryLoad.patch">patch</a></code></li>
<li><code><a title="nemo.generators.BatteryLoad.reset" href="#nemo.generators.BatteryLoad.reset">reset</a></code></li>
<li><code><a title="nemo.generators.BatteryLoad.series" href="#nemo.generators.BatteryLoad.series">series</a></code></li>
<li><code><a title="nemo.generators.BatteryLoad.soc" href="#nemo.generators.BatteryLoad.soc">soc</a></code></li>
<li><code><a title="nemo.generators.BatteryLoad.step" href="#nemo.generators.BatteryLoad.step">step</a></code></li>
<li><code><a title="nemo.generators.BatteryLoad.store" href="#nemo.generators.BatteryLoad.store">store</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nemo.generators.Behind_Meter_PV" href="#nemo.generators.Behind_Meter_PV">Behind_Meter_PV</a></code></h4>
<ul class="">
<li><code><a title="nemo.generators.Behind_Meter_PV.patch" href="#nemo.generators.Behind_Meter_PV.patch">patch</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nemo.generators.Biofuel" href="#nemo.generators.Biofuel">Biofuel</a></code></h4>
<ul class="">
<li><code><a title="nemo.generators.Biofuel.capcost" href="#nemo.generators.Biofuel.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.Biofuel.fixed_om_costs" href="#nemo.generators.Biofuel.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.Biofuel.patch" href="#nemo.generators.Biofuel.patch">patch</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nemo.generators.Biomass" href="#nemo.generators.Biomass">Biomass</a></code></h4>
<ul class="">
<li><code><a title="nemo.generators.Biomass.patch" href="#nemo.generators.Biomass.patch">patch</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nemo.generators.Black_Coal" href="#nemo.generators.Black_Coal">Black_Coal</a></code></h4>
</li>
<li>
<h4><code><a title="nemo.generators.Block" href="#nemo.generators.Block">Block</a></code></h4>
<ul class="">
<li><code><a title="nemo.generators.Block.patch" href="#nemo.generators.Block.patch">patch</a></code></li>
<li><code><a title="nemo.generators.Block.step" href="#nemo.generators.Block.step">step</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nemo.generators.CCGT" href="#nemo.generators.CCGT">CCGT</a></code></h4>
</li>
<li>
<h4><code><a title="nemo.generators.CCGT_CCS" href="#nemo.generators.CCGT_CCS">CCGT_CCS</a></code></h4>
</li>
<li>
<h4><code><a title="nemo.generators.CCS" href="#nemo.generators.CCS">CCS</a></code></h4>
</li>
<li>
<h4><code><a title="nemo.generators.CST" href="#nemo.generators.CST">CST</a></code></h4>
<ul class="">
<li><code><a title="nemo.generators.CST.patch" href="#nemo.generators.CST.patch">patch</a></code></li>
<li><code><a title="nemo.generators.CST.set_multiple" href="#nemo.generators.CST.set_multiple">set_multiple</a></code></li>
<li><code><a title="nemo.generators.CST.set_storage" href="#nemo.generators.CST.set_storage">set_storage</a></code></li>
<li><code><a title="nemo.generators.CST.step" href="#nemo.generators.CST.step">step</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nemo.generators.CSVTraceGenerator" href="#nemo.generators.CSVTraceGenerator">CSVTraceGenerator</a></code></h4>
<ul class="">
<li><code><a title="nemo.generators.CSVTraceGenerator.csvdata" href="#nemo.generators.CSVTraceGenerator.csvdata">csvdata</a></code></li>
<li><code><a title="nemo.generators.CSVTraceGenerator.csvfilename" href="#nemo.generators.CSVTraceGenerator.csvfilename">csvfilename</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nemo.generators.CentralReceiver" href="#nemo.generators.CentralReceiver">CentralReceiver</a></code></h4>
</li>
<li>
<h4><code><a title="nemo.generators.Coal_CCS" href="#nemo.generators.Coal_CCS">Coal_CCS</a></code></h4>
</li>
<li>
<h4><code><a title="nemo.generators.DemandResponse" href="#nemo.generators.DemandResponse">DemandResponse</a></code></h4>
<ul class="">
<li><code><a title="nemo.generators.DemandResponse.patch" href="#nemo.generators.DemandResponse.patch">patch</a></code></li>
<li><code><a title="nemo.generators.DemandResponse.step" href="#nemo.generators.DemandResponse.step">step</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nemo.generators.Diesel" href="#nemo.generators.Diesel">Diesel</a></code></h4>
</li>
<li>
<h4><code><a title="nemo.generators.Electrolyser" href="#nemo.generators.Electrolyser">Electrolyser</a></code></h4>
<ul class="two-column">
<li><code><a title="nemo.generators.Electrolyser.patch" href="#nemo.generators.Electrolyser.patch">patch</a></code></li>
<li><code><a title="nemo.generators.Electrolyser.reset" href="#nemo.generators.Electrolyser.reset">reset</a></code></li>
<li><code><a title="nemo.generators.Electrolyser.series" href="#nemo.generators.Electrolyser.series">series</a></code></li>
<li><code><a title="nemo.generators.Electrolyser.soc" href="#nemo.generators.Electrolyser.soc">soc</a></code></li>
<li><code><a title="nemo.generators.Electrolyser.step" href="#nemo.generators.Electrolyser.step">step</a></code></li>
<li><code><a title="nemo.generators.Electrolyser.store" href="#nemo.generators.Electrolyser.store">store</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nemo.generators.Fossil" href="#nemo.generators.Fossil">Fossil</a></code></h4>
<ul class="">
<li><code><a title="nemo.generators.Fossil.patch" href="#nemo.generators.Fossil.patch">patch</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nemo.generators.Fuelled" href="#nemo.generators.Fuelled">Fuelled</a></code></h4>
<ul class="">
<li><code><a title="nemo.generators.Fuelled.step" href="#nemo.generators.Fuelled.step">step</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nemo.generators.Generator" href="#nemo.generators.Generator">Generator</a></code></h4>
<ul class="two-column">
<li><code><a title="nemo.generators.Generator.capcost" href="#nemo.generators.Generator.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.Generator.capfactor" href="#nemo.generators.Generator.capfactor">capfactor</a></code></li>
<li><code><a title="nemo.generators.Generator.fixed_om_costs" href="#nemo.generators.Generator.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.Generator.lcoe" href="#nemo.generators.Generator.lcoe">lcoe</a></code></li>
<li><code><a title="nemo.generators.Generator.opcost" href="#nemo.generators.Generator.opcost">opcost</a></code></li>
<li><code><a title="nemo.generators.Generator.opcost_per_mwh" href="#nemo.generators.Generator.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.Generator.region" href="#nemo.generators.Generator.region">region</a></code></li>
<li><code><a title="nemo.generators.Generator.reset" href="#nemo.generators.Generator.reset">reset</a></code></li>
<li><code><a title="nemo.generators.Generator.series" href="#nemo.generators.Generator.series">series</a></code></li>
<li><code><a title="nemo.generators.Generator.set_capacity" href="#nemo.generators.Generator.set_capacity">set_capacity</a></code></li>
<li><code><a title="nemo.generators.Generator.step" href="#nemo.generators.Generator.step">step</a></code></li>
<li><code><a title="nemo.generators.Generator.storage_p" href="#nemo.generators.Generator.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.Generator.summary" href="#nemo.generators.Generator.summary">summary</a></code></li>
<li><code><a title="nemo.generators.Generator.synchronous_p" href="#nemo.generators.Generator.synchronous_p">synchronous_p</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nemo.generators.Geothermal" href="#nemo.generators.Geothermal">Geothermal</a></code></h4>
<ul class="">
<li><code><a title="nemo.generators.Geothermal.patch" href="#nemo.generators.Geothermal.patch">patch</a></code></li>
<li><code><a title="nemo.generators.Geothermal.step" href="#nemo.generators.Geothermal.step">step</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nemo.generators.Geothermal_EGS" href="#nemo.generators.Geothermal_EGS">Geothermal_EGS</a></code></h4>
</li>
<li>
<h4><code><a title="nemo.generators.Geothermal_HSA" href="#nemo.generators.Geothermal_HSA">Geothermal_HSA</a></code></h4>
</li>
<li>
<h4><code><a title="nemo.generators.Hydro" href="#nemo.generators.Hydro">Hydro</a></code></h4>
<ul class="">
<li><code><a title="nemo.generators.Hydro.patch" href="#nemo.generators.Hydro.patch">patch</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nemo.generators.HydrogenGT" href="#nemo.generators.HydrogenGT">HydrogenGT</a></code></h4>
<ul class="">
<li><code><a title="nemo.generators.HydrogenGT.capcost" href="#nemo.generators.HydrogenGT.capcost">capcost</a></code></li>
<li><code><a title="nemo.generators.HydrogenGT.fixed_om_costs" href="#nemo.generators.HydrogenGT.fixed_om_costs">fixed_om_costs</a></code></li>
<li><code><a title="nemo.generators.HydrogenGT.opcost_per_mwh" href="#nemo.generators.HydrogenGT.opcost_per_mwh">opcost_per_mwh</a></code></li>
<li><code><a title="nemo.generators.HydrogenGT.patch" href="#nemo.generators.HydrogenGT.patch">patch</a></code></li>
<li><code><a title="nemo.generators.HydrogenGT.step" href="#nemo.generators.HydrogenGT.step">step</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nemo.generators.OCGT" href="#nemo.generators.OCGT">OCGT</a></code></h4>
</li>
<li>
<h4><code><a title="nemo.generators.PV" href="#nemo.generators.PV">PV</a></code></h4>
</li>
<li>
<h4><code><a title="nemo.generators.PV1Axis" href="#nemo.generators.PV1Axis">PV1Axis</a></code></h4>
<ul class="">
<li><code><a title="nemo.generators.PV1Axis.patch" href="#nemo.generators.PV1Axis.patch">patch</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nemo.generators.ParabolicTrough" href="#nemo.generators.ParabolicTrough">ParabolicTrough</a></code></h4>
</li>
<li>
<h4><code><a title="nemo.generators.PumpedHydroPump" href="#nemo.generators.PumpedHydroPump">PumpedHydroPump</a></code></h4>
<ul class="two-column">
<li><code><a title="nemo.generators.PumpedHydroPump.patch" href="#nemo.generators.PumpedHydroPump.patch">patch</a></code></li>
<li><code><a title="nemo.generators.PumpedHydroPump.reset" href="#nemo.generators.PumpedHydroPump.reset">reset</a></code></li>
<li><code><a title="nemo.generators.PumpedHydroPump.series" href="#nemo.generators.PumpedHydroPump.series">series</a></code></li>
<li><code><a title="nemo.generators.PumpedHydroPump.soc" href="#nemo.generators.PumpedHydroPump.soc">soc</a></code></li>
<li><code><a title="nemo.generators.PumpedHydroPump.step" href="#nemo.generators.PumpedHydroPump.step">step</a></code></li>
<li><code><a title="nemo.generators.PumpedHydroPump.store" href="#nemo.generators.PumpedHydroPump.store">store</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nemo.generators.PumpedHydroTurbine" href="#nemo.generators.PumpedHydroTurbine">PumpedHydroTurbine</a></code></h4>
<ul class="">
<li><code><a title="nemo.generators.PumpedHydroTurbine.step" href="#nemo.generators.PumpedHydroTurbine.step">step</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nemo.generators.Storage" href="#nemo.generators.Storage">Storage</a></code></h4>
<ul class="two-column">
<li><code><a title="nemo.generators.Storage.charge_capacity" href="#nemo.generators.Storage.charge_capacity">charge_capacity</a></code></li>
<li><code><a title="nemo.generators.Storage.record" href="#nemo.generators.Storage.record">record</a></code></li>
<li><code><a title="nemo.generators.Storage.reset" href="#nemo.generators.Storage.reset">reset</a></code></li>
<li><code><a title="nemo.generators.Storage.series" href="#nemo.generators.Storage.series">series</a></code></li>
<li><code><a title="nemo.generators.Storage.soc" href="#nemo.generators.Storage.soc">soc</a></code></li>
<li><code><a title="nemo.generators.Storage.storage_p" href="#nemo.generators.Storage.storage_p">storage_p</a></code></li>
<li><code><a title="nemo.generators.Storage.store" href="#nemo.generators.Storage.store">store</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nemo.generators.TraceGenerator" href="#nemo.generators.TraceGenerator">TraceGenerator</a></code></h4>
<ul class="">
<li><code><a title="nemo.generators.TraceGenerator.csvdata" href="#nemo.generators.TraceGenerator.csvdata">csvdata</a></code></li>
<li><code><a title="nemo.generators.TraceGenerator.csvfilename" href="#nemo.generators.TraceGenerator.csvfilename">csvfilename</a></code></li>
<li><code><a title="nemo.generators.TraceGenerator.step" href="#nemo.generators.TraceGenerator.step">step</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nemo.generators.Wind" href="#nemo.generators.Wind">Wind</a></code></h4>
<ul class="">
<li><code><a title="nemo.generators.Wind.patch" href="#nemo.generators.Wind.patch">patch</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nemo.generators.WindOffshore" href="#nemo.generators.WindOffshore">WindOffshore</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>